<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.png?v=5.1.4" color="#222">





  <meta name="keywords" content="Python,并查集,">










<meta name="description" content="题目描述给你一个字符串 s，以及该字符串中的一些「索引对」数组 pairs，其中 pairs[i] = [a, b] 表示字符串中的两个索引（编号从 0 开始）。 你可以 任意多次交换 在 pairs 中任意一对索引处的字符。 返回在经过若干次交换后，s 可以变成的按字典序最小的字符串。">
<meta name="keywords" content="Python,并查集">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode-并查集-交换字符串中的元素">
<meta property="og:url" content="http://yoursite.com/2021/01/11/LeetCode-并查集-交换字符串中的元素/index.html">
<meta property="og:site_name" content="Essays">
<meta property="og:description" content="题目描述给你一个字符串 s，以及该字符串中的一些「索引对」数组 pairs，其中 pairs[i] = [a, b] 表示字符串中的两个索引（编号从 0 开始）。 你可以 任意多次交换 在 pairs 中任意一对索引处的字符。 返回在经过若干次交换后，s 可以变成的按字典序最小的字符串。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/2021/01/11/LeetCode-并查集-交换字符串中的元素/并查集1.jpg">
<meta property="og:image" content="http://yoursite.com/2021/01/11/LeetCode-并查集-交换字符串中的元素/并查集2.jpg">
<meta property="og:image" content="http://yoursite.com/2021/01/11/LeetCode-并查集-交换字符串中的元素/并查集3.jpg">
<meta property="og:image" content="http://yoursite.com/2021/01/11/LeetCode-并查集-交换字符串中的元素/并查集4.jpg">
<meta property="og:image" content="http://yoursite.com/2021/01/11/LeetCode-并查集-交换字符串中的元素/并查集5.jpg">
<meta property="og:image" content="http://yoursite.com/2021/01/11/LeetCode-并查集-交换字符串中的元素/并查集6.png">
<meta property="og:image" content="http://yoursite.com/2021/01/11/LeetCode-并查集-交换字符串中的元素/并查集7.jpg">
<meta property="og:image" content="http://yoursite.com/2021/01/11/LeetCode-并查集-交换字符串中的元素/并查集8.jpg">
<meta property="og:image" content="http://yoursite.com/2021/01/11/LeetCode-并查集-交换字符串中的元素/result.png">
<meta property="og:updated_time" content="2021-01-11T13:57:24.297Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeetCode-并查集-交换字符串中的元素">
<meta name="twitter:description" content="题目描述给你一个字符串 s，以及该字符串中的一些「索引对」数组 pairs，其中 pairs[i] = [a, b] 表示字符串中的两个索引（编号从 0 开始）。 你可以 任意多次交换 在 pairs 中任意一对索引处的字符。 返回在经过若干次交换后，s 可以变成的按字典序最小的字符串。">
<meta name="twitter:image" content="http://yoursite.com/2021/01/11/LeetCode-并查集-交换字符串中的元素/并查集1.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>
 
<script>
    (function(){
        if(''){
            if (prompt('请输入密码') !== ''){
                alert('密码错误');
                history.back();
            }
        }
    })();
</script>


  <link rel="canonical" href="http://yoursite.com/2021/01/11/LeetCode-并查集-交换字符串中的元素/">





  <title>LeetCode-并查集-交换字符串中的元素 | Essays</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Essays</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/11/LeetCode-并查集-交换字符串中的元素/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wbg">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Essays">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">LeetCode-并查集-交换字符串中的元素</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-01-11T00:00:00+08:00">
                2021-01-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/LeetCode/" itemprop="url" rel="index">
                    <span itemprop="name">LeetCode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.6k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  10
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你一个字符串 s，以及该字符串中的一些「索引对」数组 pairs，其中 pairs[i] = [a, b] 表示字符串中的两个索引（编号从 0 开始）。</p>
<p>你可以 任意多次交换 在 pairs 中任意一对索引处的字符。</p>
<p>返回在经过若干次交换后，s 可以变成的按字典序最小的字符串。</p>
<a id="more"></a>
<p>示例 1:</p>
<p>输入：s = “dcab”, pairs = [[0,3],[1,2]]<br>输出：”bacd”<br>解释：<br>交换 s[0] 和 s[3], s = “bcad”<br>交换 s[1] 和 s[2], s = “bacd”</p>
<p>示例 2：</p>
<p>输入：s = “dcab”, pairs = [[0,3],[1,2],[0,2]]<br>输出：”abcd”<br>解释：<br>交换 s[0] 和 s[3], s = “bcad”<br>交换 s[0] 和 s[2], s = “acbd”<br>交换 s[1] 和 s[2], s = “abcd”</p>
<p>示例 3：</p>
<p>输入：s = “cba”, pairs = [[0,1],[1,2]]<br>输出：”abc”<br>解释：<br>交换 s[0] 和 s[1], s = “bca”<br>交换 s[1] 和 s[2], s = “bac”<br>交换 s[0] 和 s[1], s = “abc”</p>
<p>提示：</p>
<p>1 &lt;= s.length &lt;= 10^5<br>0 &lt;= pairs.length &lt;= 10^5<br>0 &lt;= pairs[i][0], pairs[i][1] &lt; s.length<br>s 中只含有小写英文字母</p>
<p><a href="https://leetcode-cn.com/problems/smallest-string-with-swaps" target="_blank" rel="noopener">题目链接</a></p>
<p>如果懂并查集，该题目一眼就可以看出是并查集相关题目。然而我不懂orz，所以先学习并查集相关内容。</p>
<h4 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h4><p>并查集主要用于解决一些<strong>元素分组</strong>的问题。它管理一系列<strong>不相交的集合</strong>，并支持两种操作：</p>
<ul>
<li><strong>合并</strong>（Union）：把两个不相交的集合合并为一个集合。</li>
<li><strong>查询</strong>（Find）：查询两个元素是否在同一个集合中。</li>
</ul>
<p>并查集的重要思想在于，<strong>用集合中的一个元素代表集合</strong>。</p>
<p>通俗地讲，将各元素看做一点，有联系的两点之间有通路，最终形成图结构，该图包含一个或多个连通分支。</p>
<p><img src="/2021/01/11/LeetCode-并查集-交换字符串中的元素/并查集1.jpg" alt="并查集1"></p>
<p>初始的6个节点。</p>
<p><img src="/2021/01/11/LeetCode-并查集-交换字符串中的元素/并查集2.jpg" alt="并查集1"></p>
<p>1与3相关联，建立通路，此时设1为该集合的代表元素。</p>
<p><img src="/2021/01/11/LeetCode-并查集-交换字符串中的元素/并查集3.jpg" alt="并查集1"></p>
<p>此时，2与3相关联，2可与3建立通路，也可与1建立通路（只要属于同一集合即可），我们让各自的根节点（代表元素）与代表元素建立通路，即1和2。（为什么取这样后文讨论）</p>
<p><img src="/2021/01/11/LeetCode-并查集-交换字符串中的元素/并查集4.jpg" alt="并查集1"></p>
<p>同理，4、5和6相关联，建立通路。</p>
<p><img src="/2021/01/11/LeetCode-并查集-交换字符串中的元素/并查集5.jpg" alt="并查集1"></p>
<p>此时，6和3相关联，所以在两个代表元素1和4之间建立通路，取1为代表元素（取4也可，后文讨论）。</p>
<p><img src="/2021/01/11/LeetCode-并查集-交换字符串中的元素/并查集6.png" alt="并查集1"></p>
<p>最终得到的结构如图，是一个图结构。由图可知，寻找某个节点的所属的集合只要层层向上访问父节点，直到根节点（代表元素）即可。</p>
<p>由此，我们可以得出并查集的简单代码：</p>
<p><strong>初始化</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> father[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		father[i] = i;<span class="comment">//初始各节点的父节点为自己本身</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假如有编号为1, 2, 3, …, n的n个元素，我们用一个数组fa[]来存储每个元素的父节点（因为每个元素有且只有一个父节点，所以这是可行的）。一开始，我们先将它们的父节点设为自己。</p>
<p><strong>查询</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(father[x] == x)</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> find(father[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用递归实现对代表元素的查询：一层一层访问父节点，直至根节点（根节点的标志就是父节点是其本身）。要判断两个元素是否属于同一个集合，只需要看它们的根节点是否相同即可。</p>
<p><strong>合并</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	fx = find(x);</span><br><span class="line">	fy = find(y);</span><br><span class="line">	father[fx] = fy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>合并操作即，先找到两个集合的代表元素，然后将前者的父节点设为后者即可。（当然也可以将后者的父节点设为前者，后文讨论。）</p>
<p>至此，我们得到了并查集的基本操作。</p>
<h5 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h5><p>上文提到，2与3相关联，2可与3建立通路，也可与1建立通路（只要属于同一集合即可），我们取的与1的通路。假设我们取2与3的通路，则1、2和3之间变为一条单链。同理，4、5、6也是单链。此时，6与3建立通路，整个结构变为6个节点的单链，此时查询根节点的开销随着距离根节点的距离增大逐渐增大。</p>
<p>但是我们关心的仅为某一元素对应的集合（即根节点），当然希望每个元素到根节点的路径尽可能短，最好只需要一步。</p>
<p>所以只要在查询的过程中，<strong>把沿途的每个节点的父节点都设为根节点</strong>即可。下一次再查询时，我们就可以节省时间。递归实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == father[x])</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        father[x] = find(father[x]);  <span class="comment">//父节点设为根节点</span></span><br><span class="line">        <span class="keyword">return</span> fa[x];	<span class="comment">//返回父节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="按深度合并"><a href="#按深度合并" class="headerlink" title="按深度合并"></a>按深度合并</h5><p>在合并两个树时，如果单纯地将前者合并到后者，容易使得合并后的树结构变复杂。</p>
<p><img src="/2021/01/11/LeetCode-并查集-交换字符串中的元素/并查集7.jpg" alt="并查集7"></p>
<p>如图，合并7、8时，会面临两种选择：</p>
<p><img src="/2021/01/11/LeetCode-并查集-交换字符串中的元素/并查集8.jpg" alt="并查集8"></p>
<p>很明显选后者。因为如果把7的父节点设为8，会使树的<strong>深度</strong>（树中最长链的长度）加深，原来的树中每个元素到根节点的距离都变长了，之后我们寻找根节点的路径也就会相应变长。虽然我们有路径压缩，但路径压缩也是会消耗时间的。而把8的父节点设为7，则不会有这个问题，因为它没有影响到不相关的节点。</p>
<p>因此，我们在合并时，<strong>应该把简单的树往复杂的树上合并，而不是相反。因为这样合并后，到根节点距离变长的节点个数比较少。</strong></p>
<p>用一个数组rank[]记录每个根节点对应的树的深度（如果不是根节点，其rank相当于以它作为根节点的<strong>子树</strong>的深度）。一开始，把所有元素的rank设为1。合并时比较两个根节点，把rank较小者往较大者上合并。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">        rank[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = find(i), y = find(j);    <span class="comment">//先找到两个根节点</span></span><br><span class="line">    <span class="keyword">if</span> (rank[x] &lt;= rank[y])</span><br><span class="line">        fa[x] = y;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        fa[y] = x;</span><br><span class="line">    <span class="keyword">if</span> (rank[x] == rank[y] &amp;&amp; x != y)</span><br><span class="line">        rank[y]++;                   <span class="comment">//如果深度相同且根节点不同，则新的根节点的深度+1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，讨论完了并查集的相关内容。我们回到题目本身。</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>学习完并查集相关内容后，思路自然而然地产生了：利用并查集，将s中的字符元素分成多个集合，对每个集合中的元素分别进行排序，插回原字符串即可。</p>
<p>（此时，单纯的我还不知道自己给自己挖的坑。）</p>
<p>程序流程如下：</p>
<p>利用并查集分类 -&gt; 筛选分组 -&gt; 排序 -&gt; 插回。</p>
<h5 id="代码1-0"><a href="#代码1-0" class="headerlink" title="代码1.0"></a>代码1.0</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    father = []</span><br><span class="line">    rank = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">smallestStringWithSwaps</span><span class="params">(self, s: str, pairs: List[List[int]])</span> -&gt; str:</span></span><br><span class="line">        length = len(s)</span><br><span class="line">        group_dic = &#123;&#125;</span><br><span class="line">        self.init(length)</span><br><span class="line">        <span class="keyword">for</span> pair <span class="keyword">in</span> pairs:</span><br><span class="line">            self.merge(pair[<span class="number">0</span>],pair[<span class="number">1</span>])</span><br><span class="line">        <span class="comment"># 对每一个元素进行分组</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,length):</span><br><span class="line">            x = self.find(i)</span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> group_dic.keys():</span><br><span class="line">                group_dic[x] = [s[i]]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                group_dic[x].append(s[i])</span><br><span class="line">        <span class="comment">#对每一个分组中序号对应的元素组成的逻辑上的数组进行 选择排序</span></span><br><span class="line">        <span class="comment"># 不得不吐槽，这个排序毫无用处还把👴绕晕了</span></span><br><span class="line">        l = list(s)</span><br><span class="line">        <span class="keyword">for</span> group <span class="keyword">in</span> group_dic.values():</span><br><span class="line">            group.sort()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(group)<span class="number">-1</span>):</span><br><span class="line">                m = group[i]</span><br><span class="line">                mini = m</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,len(group)):</span><br><span class="line">                    n = group[j]</span><br><span class="line">                    <span class="keyword">if</span> l[n] &lt; l[mini]:</span><br><span class="line">                        mini = n</span><br><span class="line">                temp = l[m]</span><br><span class="line">                l[m] = l[mini]</span><br><span class="line">                l[mini] = temp</span><br><span class="line">        s = <span class="string">''</span>.join(l)</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        self.father = [<span class="number">0</span>]*n</span><br><span class="line">        self.rank = [<span class="number">1</span>]*n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n):</span><br><span class="line">            self.father[i] = i</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.father[x] == x:</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment">#路径压缩，将父节点设为根节点</span></span><br><span class="line">            self.father[x] = self.find(self.father[x])</span><br><span class="line">            <span class="keyword">return</span> self.father[x]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        father_x = self.find(x)</span><br><span class="line">        father_y = self.find(y)</span><br><span class="line">        <span class="keyword">if</span> father_x != father_y:</span><br><span class="line">            self.father[father_x] = father_y</span><br></pre></td></tr></table></figure>
<p>debug环节省略，磕磕碰碰把代码写出来，过了test，提交！然后不出意料的，超时了orz</p>
<p>很明显，选择排序在元素数量多时表现太差了。</p>
<p>因此换一种思路：既然我已经对元素分好了组，那么我可以在组内进行排序，然后遍历整个字符串，每个位置属于某个分组时，取出该分组中的最小元素填入该位置即可。</p>
<h5 id="代码1-1"><a href="#代码1-1" class="headerlink" title="代码1.1"></a>代码1.1</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    father = []</span><br><span class="line">    rank = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">smallestStringWithSwaps</span><span class="params">(self, s: str, pairs: List[List[int]])</span> -&gt; str:</span></span><br><span class="line">        length = len(s)</span><br><span class="line">        group_dic = &#123;&#125;</span><br><span class="line">        self.init(length)</span><br><span class="line">        <span class="keyword">for</span> pair <span class="keyword">in</span> pairs:</span><br><span class="line">            self.merge(pair[<span class="number">0</span>],pair[<span class="number">1</span>])</span><br><span class="line">        <span class="comment"># 对每一个元素进行分组</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,length):</span><br><span class="line">            x = self.find(i)</span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> group_dic.keys():</span><br><span class="line">                group_dic[x] = [s[i]]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                group_dic[x].append(s[i])</span><br><span class="line">        <span class="comment">#对于某一集合，逐个取出最小元素</span></span><br><span class="line">        <span class="keyword">for</span> group <span class="keyword">in</span> group_dic.values():</span><br><span class="line">            group.sort()</span><br><span class="line">        l = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,length):</span><br><span class="line">            x = self.find(i)</span><br><span class="line">            l.append(group_dic[x][<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">del</span>(group_dic[x][<span class="number">0</span>])</span><br><span class="line">        s = <span class="string">''</span>.join(l)</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        self.father = [<span class="number">0</span>]*n</span><br><span class="line">        self.rank = [<span class="number">1</span>]*n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n):</span><br><span class="line">            self.father[i] = i</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.father[x] == x:</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment">#路径压缩，将父节点设为根节点</span></span><br><span class="line">            self.father[x] = self.find(self.father[x])</span><br><span class="line">            <span class="keyword">return</span> self.father[x]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        father_x = self.find(x)</span><br><span class="line">        father_y = self.find(y)</span><br><span class="line">        <span class="keyword">if</span> father_x != father_y:</span><br><span class="line">            self.father[father_x] = father_y</span><br></pre></td></tr></table></figure>
<p>提交代码，终于通过。虽然结果很烂，但是不想改了，打开官方题解研究一下。</p>
<p><img src="/2021/01/11/LeetCode-并查集-交换字符串中的元素/result.png" alt="result"></p>
<p><a href="https://leetcode-cn.com/problems/smallest-string-with-swaps/solution/jiao-huan-zi-fu-chuan-zhong-de-yuan-su-b-qdn9/" target="_blank" rel="noopener">官方题解</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#并查集基本操作，没什么好说的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DisjointSetUnion</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n: int)</span>:</span></span><br><span class="line">        self.n = n</span><br><span class="line">        self.rank = [<span class="number">1</span>] * n</span><br><span class="line">        self.f = list(range(n))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, x: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> self.f[x] == x:</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        self.f[x] = self.find(self.f[x])</span><br><span class="line">        <span class="keyword">return</span> self.f[x]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">unionSet</span><span class="params">(self, x: int, y: int)</span>:</span></span><br><span class="line">        fx, fy = self.find(x), self.find(y)</span><br><span class="line">        <span class="keyword">if</span> fx == fy:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> self.rank[fx] &lt; self.rank[fy]:</span><br><span class="line">            fx, fy = fy, fx</span><br><span class="line">        self.rank[fx] += self.rank[fy]</span><br><span class="line">        self.f[fy] = fx</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">smallestStringWithSwaps</span><span class="params">(self, s: str, pairs: List[List[int]])</span> -&gt; str:</span></span><br><span class="line">        dsu = DisjointSetUnion(len(s))</span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> pairs:</span><br><span class="line">            dsu.unionSet(x, y)</span><br><span class="line">        <span class="comment">#这里使用默认返回list的字典，解决了Nonetype不能append的问题（👴遇到了）</span></span><br><span class="line">        mp = collections.defaultdict(list)</span><br><span class="line">        <span class="comment">#这里使用枚举enumerate() 函数，简单方便，👴不会，学到了</span></span><br><span class="line">        <span class="keyword">for</span> i, ch <span class="keyword">in</span> enumerate(s):</span><br><span class="line">            mp[dsu.find(i)].append(ch)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> vec <span class="keyword">in</span> mp.values():</span><br><span class="line">            vec.sort(reverse=<span class="literal">True</span>)</span><br><span class="line">        </span><br><span class="line">        ans = list()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            x = dsu.find(i)</span><br><span class="line">            ans.append(mp[x][<span class="number">-1</span>])</span><br><span class="line">            <span class="comment">#这里使用pop弹出末尾元素，简洁</span></span><br><span class="line">            mp[x].pop()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join(ans)</span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Python/" rel="tag"><i class="fa fa-tag"></i> Python</a>
          
            <a href="/tags/并查集/" rel="tag"><i class="fa fa-tag"></i> 并查集</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/08/03/LeetCode-3-无重复字符的最长子串/" rel="next" title="LeetCode-3-无重复字符的最长子串">
                <i class="fa fa-chevron-left"></i> LeetCode-3-无重复字符的最长子串
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">wbg</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#题目描述"><span class="nav-number">1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#并查集"><span class="nav-number">2.</span> <span class="nav-text">并查集</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#路径压缩"><span class="nav-number">2.1.</span> <span class="nav-text">路径压缩</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#按深度合并"><span class="nav-number">2.2.</span> <span class="nav-text">按深度合并</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解题思路"><span class="nav-number">3.</span> <span class="nav-text">解题思路</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#代码1-0"><span class="nav-number">3.1.</span> <span class="nav-text">代码1.0</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#代码1-1"><span class="nav-number">3.2.</span> <span class="nav-text">代码1.1</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wbg</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">10k</span>
  
</div>

<!--
  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>



-->

        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  

<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body>
</html>
