<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LeetCode-684-冗余连接</title>
      <link href="/2021/01/14/LeetCode-684-%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5/"/>
      <url>/2021/01/14/LeetCode-684-%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>在本问题中, 树指的是一个连通且无环的无向图。</p><p>输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, …, N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。</p><p>结果图是一个以边组成的二维数组。每一个边的元素是一对[u, v] ，满足 u &lt; v，表示连接顶点u 和v的无向图的边。</p><p>返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 [u, v] 应满足相同的格式 u &lt; v。</p><a id="more"></a><p>示例 1：</p><p>输入: [[1,2], [1,3], [2,3]]<br>输出: [2,3]<br>解释: 给定的无向图为:<br>  1<br> / \<br>2 - 3<br>示例 2：</p><p>输入: [[1,2], [2,3], [3,4], [1,4], [1,5]]<br>输出: [1,4]<br>解释: 给定的无向图为:<br>5 - 1 - 2<br>    |   |<br>    4 - 3<br>注意:</p><p>输入的二维数组大小在 3 到 1000。<br>二维数组中的整数在1到N之间，其中N是输入数组的大小。</p><p><a href="https://leetcode-cn.com/problems/redundant-connection" target="_blank" rel="noopener">题目链接</a></p><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>根据标题“冗余连接”以及题目描述，梳理出大致题意为：给定的图原本是树形，即无环路。现在加了多条冗余边，形成了某两点之间的多重路径。我们要做的就是找出图中添加的这些边。这些边的特征很明显，即对应的顶点之间具有多条路径。因此，当我们遍历边集时，将连通的两个顶点放进同一集合，若此后再次遍历到同属同一集合的两顶点，则可以确认这两个顶点组成的边是冗余边。</p><p>因此，利用并查集，将所有的点归并到同一集合，如果发现两个点同属同一集合，则该边为目标边。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    father = []</span><br><span class="line">    <span class="comment">#这道题没提及rank，所以不用了，区别不大</span></span><br><span class="line">    <span class="comment">#rank = []</span></span><br><span class="line">    re = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRedundantConnection</span><span class="params">(self, edges)</span> :</span></span><br><span class="line">        self.init(len(edges)+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> edge <span class="keyword">in</span> edges:</span><br><span class="line">            <span class="keyword">if</span> self.find(edge[<span class="number">0</span>]) != self.find(edge[<span class="number">1</span>]):</span><br><span class="line">                self.merge(edge[<span class="number">0</span>],edge[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> [edge[<span class="number">0</span>],edge[<span class="number">1</span>]]</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="comment">#初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment">#这一行是重要代码</span></span><br><span class="line">        father = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            self.father.append(int(i))</span><br><span class="line">            <span class="comment">#self.rank.append(1)</span></span><br><span class="line">    <span class="comment">#并查集两件套</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.father[x] == x:</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.father[x] = self.find(self.father[x])</span><br><span class="line">            <span class="keyword">return</span> self.father[x]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        f_x = self.find(x)</span><br><span class="line">        f_y = self.find(y)</span><br><span class="line">        self.father[f_y] = f_x</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>前两天刚学了并查集，没想到，这么快又用上了。然而👴做了一晚上，也提交不上。本地怎么测怎么对，交上去答案就是不一样。调了一晚上，每行都改了，就差改成官方题解了，给爷嘴都气歪喽。</p><p>最后，👴终于知道哪儿出问题了。原来是LeetCode在加载类时，只加载一次，往后循环使用，没有初始化参数。所以👴的代码出了问题。👴加了一行代码，终于过了。给👴上了一课，👴以后长记性了，以后不写类内函数了，👴直接嵌套，调用起来也方便，也没这么多事。总之，👴属实脑瘫。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集，Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-拓扑排序-项目管理</title>
      <link href="/2021/01/12/LeetCode-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F-%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
      <url>/2021/01/12/LeetCode-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F-%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>公司共有 n 个项目和  m 个小组，每个项目要不无人接手，要不就由 m 个小组之一负责。</p><p>group[i] 表示第 i 个项目所属的小组，如果这个项目目前无人接手，那么 group[i] 就等于 -1。（项目和小组都是从零开始编号的）小组可能存在没有接手任何项目的情况。</p><p>请你帮忙按要求安排这些项目的进度，并返回排序后的项目列表：</p><p>同一小组的项目，排序后在列表中彼此相邻。<br>项目之间存在一定的依赖关系，我们用一个列表 beforeItems 来表示，其中 beforeItems[i] 表示在进行第 i 个项目前（位于第 i 个项目左侧）应该完成的所有项目。<br>如果存在多个解决方案，只需要返回其中任意一个即可。如果没有合适的解决方案，就请返回一个 空列表 。</p><a id="more"></a><p>示例 1：</p><p><img src="/2021/01/12/LeetCode-拓扑排序-项目管理/示例1.png" alt="示例1"></p><p>输入：n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3,6],[],[],[]]<br>输出：[6,3,4,1,5,2,0,7]<br>示例 2：</p><p>输入：n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3],[],[4],[]]<br>输出：[]<br>解释：与示例 1 大致相同，但是在排序后的列表中，4 必须放在 6 的前面。</p><p>提示：</p><p>1 &lt;= m &lt;= n &lt;= 3 * 104<br>group.length == beforeItems.length == n<br>-1 &lt;= group[i] &lt;= m - 1<br>0 &lt;= beforeItems[i].length &lt;= n - 1<br>0 &lt;= beforeItems[i][j] &lt;= n - 1<br>i != beforeItems[i][j]<br>beforeItems[i] 不含重复元素</p><p><a href="https://leetcode-cn.com/problems/sort-items-by-groups-respecting-dependencies" target="_blank" rel="noopener">题目链接</a></p><h4 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h4><h5 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h5><p>在图论中，<strong>拓扑排序（Topological Sorting</strong>）是一个有向无环图（DAG, Directed Acyclic Graph）的所有顶点的线性序列。且该序列必须满足下面两个条件：</p><ol><li>每个顶点出现且只出现一次。</li><li>若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。</li></ol><p>有向无环图（DAG）才有拓扑排序，非DAG图没有拓扑排序一说。</p><p>如何写出拓扑排序呢？比较常用的方法：</p><ol><li>从 DAG 图中选择一个 没有前驱（即入度为0）的顶点并输出。</li><li>从图中删除该顶点和所有以它为起点的有向边。</li><li>重复 1 和 2 直到当前的 DAG 图为空或当前图中不存在无前驱的顶点为止。后一种情况说明有向图中必然存在环。</li></ol><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用字典结构表示图的邻接表，key为点，value为邻接点的集合</span></span><br><span class="line">Graph = &#123;A:[B,C],</span><br><span class="line">         B:[D],</span><br><span class="line">         C:[],</span><br><span class="line">         D:[]</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">#假设入度表也用字典结构表示</span></span><br><span class="line">inDegree = &#123;A:<span class="number">0</span>,</span><br><span class="line">           B:<span class="number">1</span>,</span><br><span class="line">           C:<span class="number">1</span>,</span><br><span class="line">           D:<span class="number">1</span></span><br><span class="line">          &#125;</span><br><span class="line"><span class="comment">#随手写的拓扑排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">topSort</span><span class="params">(graph, inDegree)</span>:</span></span><br><span class="line">    q = queue.Queue()</span><br><span class="line">    n = len(graph)<span class="comment">#计数标志位</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        find = <span class="number">0</span><span class="comment">#遍历结果标志位</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(graph)):</span><br><span class="line">            <span class="keyword">if</span> inDegree[i] == <span class="number">0</span>:</span><br><span class="line">                q.put(i)</span><br><span class="line">                inDegree[i] = <span class="number">-1</span><span class="comment">#入度置-1，表示移除</span></span><br><span class="line">                <span class="comment">#邻接点入度减1</span></span><br><span class="line">                <span class="keyword">for</span> point <span class="keyword">in</span> graph[i]:</span><br><span class="line">                    inDegree[point] -= <span class="number">1</span></span><br><span class="line">                n -= <span class="number">1</span></span><br><span class="line">                find = <span class="number">1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">   <span class="comment">#没有入度为0的点，表示存在环，无拓扑排序</span></span><br><span class="line">        <span class="keyword">if</span> find == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">       result.append(q.get())</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><h5 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h5><p>回到题目上来，👴刚学会拓扑排序，这个题直接拿拓扑排序的嵌套砸脸上，👴跪了。</p><p>题目描述弯弯绕绕，阅读理解做了半天。</p><p>首先题目内容分成两块，一块是小组，一块是项目。</p><p>每个项目由一个小组负责。</p><p>有些项目具有前置项目，前置项目做完才能进行。</p><p>这两句话的隐含内容，可以理解为，<strong>若某小组负责的某项目，其前置项目为另外一小组负责，则另外一小组为本小组的前置小组</strong>。</p><p>由此，我们得出思路：</p><p><strong>对小组间进行拓扑排序，若存在序列，则对小组负责的项目进行拓扑排序，最后按序插入即可。</strong></p><p>首要问题就是建立起小组间的依赖图。遍历group期间，发现无人负责的项目小组编号全为-1，其实是不存在的小组，但是会建立不存在的依赖关系。为了方便起见，先对无人负责项目进行重分配。因为只有m个小组，最大编号为m-1，所以对无人负责的小组从m开始，依次编号（是谁负责无所谓，只是为了方便区分）。</p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment">#若某小组负责的某项目，其前置项目为另外一小组负责，则另外一小组为本小组的前置小组</span></span><br><span class="line">    <span class="comment">#建立小组间关系图，存在拓扑排序则对本小组负责的项目进行拓扑排序</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortItems</span><span class="params">(self, n, m, group, beforeItems)</span> :</span></span><br><span class="line">        <span class="comment">#对无小组负责（即编号都为-1）的项目进行重编号，方便处理</span></span><br><span class="line">        tempGroup = m</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n):</span><br><span class="line">            <span class="keyword">if</span> group[i] == <span class="number">-1</span>:</span><br><span class="line">                group[i] = tempGroup</span><br><span class="line">                tempGroup += <span class="number">1</span></span><br><span class="line">        <span class="comment">#建立小组和项目的图以及入度表</span></span><br><span class="line">        programIndgree = collections.defaultdict(int)</span><br><span class="line">        groupIndgree = collections.defaultdict(int)</span><br><span class="line">        programGraph = collections.defaultdict(list)</span><br><span class="line">        groupGraph = collections.defaultdict(list)</span><br><span class="line">        <span class="comment">#初始化</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n):</span><br><span class="line">            programGraph[i] = []</span><br><span class="line">            programIndgree[i] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,tempGroup):</span><br><span class="line">            groupGraph[i] = []</span><br><span class="line">            groupIndgree[i] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n):</span><br><span class="line">            <span class="keyword">for</span> pre <span class="keyword">in</span> beforeItems[i]:</span><br><span class="line">                <span class="comment">#i = 4  pre = 3 3-&gt;4</span></span><br><span class="line">                programGraph[pre].append(i)</span><br><span class="line">                programIndgree[i] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> group[pre] != group[i]:</span><br><span class="line">                    groupGraph[group[pre]].append(group[i])</span><br><span class="line">                    groupIndgree[group[i]] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#建立组内项目索引，方便后续对program排序</span></span><br><span class="line">        groupProgram = collections.defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n):</span><br><span class="line">            groupProgram[group[i]].append(i)</span><br><span class="line">        <span class="comment">#group topSort</span></span><br><span class="line">        gpoint = groupGraph.keys()</span><br><span class="line">        groupQ = self.topSort(groupIndgree, groupGraph, gpoint)</span><br><span class="line">        <span class="keyword">if</span> groupQ == []:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment">#program topSort</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> groupQ:</span><br><span class="line">            points = groupProgram[i]</span><br><span class="line">            <span class="keyword">if</span> points == []:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            tempresult = self.topSort(programIndgree, programGraph, points)</span><br><span class="line">            <span class="keyword">if</span> tempresult == []:</span><br><span class="line">                <span class="keyword">return</span> []</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result += tempresult</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="comment">#为了能复用，做了改动，添加points参数表名对哪些点进行sort。</span></span><br><span class="line">    <span class="comment">#对group排序的时候无影响，points包含所有group</span></span><br><span class="line">    <span class="comment">#对program排序的时候，points只包含该group所负责的内容</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topSort</span><span class="params">(self, indgree, graph, points)</span>:</span></span><br><span class="line">        n = len(points)</span><br><span class="line">        q = queue.Queue()</span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            find = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> point <span class="keyword">in</span> points:</span><br><span class="line">                <span class="keyword">if</span> indgree[point] == <span class="number">0</span>:</span><br><span class="line">                    find = <span class="number">1</span></span><br><span class="line">                    q.put(point)</span><br><span class="line">                    n -= <span class="number">1</span></span><br><span class="line">                    indgree[point] = <span class="number">-1</span></span><br><span class="line">                    <span class="keyword">for</span> j <span class="keyword">in</span> graph[point]:</span><br><span class="line">                        indgree[j] -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> find == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> []</span><br><span class="line">        result =[]</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">            result.append(q.get())</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>然而，在验证最后一个样例的时候超时了。orz</p><p>虽然但是，👴不想改了，也不知道怎么改。很遗憾的，官方题解没给Python代码。</p><p>就这样吧，姑且当做它过了，👴真的累了。以后有空回来看再改，希望那时候👴一眼就能看出来哪里能优化。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 拓扑排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-并查集-交换字符串中的元素</title>
      <link href="/2021/01/11/LeetCode-%E5%B9%B6%E6%9F%A5%E9%9B%86-%E4%BA%A4%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0/"/>
      <url>/2021/01/11/LeetCode-%E5%B9%B6%E6%9F%A5%E9%9B%86-%E4%BA%A4%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你一个字符串 s，以及该字符串中的一些「索引对」数组 pairs，其中 pairs[i] = [a, b] 表示字符串中的两个索引（编号从 0 开始）。</p><p>你可以 任意多次交换 在 pairs 中任意一对索引处的字符。</p><p>返回在经过若干次交换后，s 可以变成的按字典序最小的字符串。</p><a id="more"></a><p>示例 1:</p><p>输入：s = “dcab”, pairs = [[0,3],[1,2]]<br>输出：”bacd”<br>解释：<br>交换 s[0] 和 s[3], s = “bcad”<br>交换 s[1] 和 s[2], s = “bacd”</p><p>示例 2：</p><p>输入：s = “dcab”, pairs = [[0,3],[1,2],[0,2]]<br>输出：”abcd”<br>解释：<br>交换 s[0] 和 s[3], s = “bcad”<br>交换 s[0] 和 s[2], s = “acbd”<br>交换 s[1] 和 s[2], s = “abcd”</p><p>示例 3：</p><p>输入：s = “cba”, pairs = [[0,1],[1,2]]<br>输出：”abc”<br>解释：<br>交换 s[0] 和 s[1], s = “bca”<br>交换 s[1] 和 s[2], s = “bac”<br>交换 s[0] 和 s[1], s = “abc”</p><p>提示：</p><p>1 &lt;= s.length &lt;= 10^5<br>0 &lt;= pairs.length &lt;= 10^5<br>0 &lt;= pairs[i][0], pairs[i][1] &lt; s.length<br>s 中只含有小写英文字母</p><p><a href="https://leetcode-cn.com/problems/smallest-string-with-swaps" target="_blank" rel="noopener">题目链接</a></p><p>如果懂并查集，该题目一眼就可以看出是并查集相关题目。然而我不懂orz，所以先学习并查集相关内容。</p><h4 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h4><p>并查集主要用于解决一些<strong>元素分组</strong>的问题。它管理一系列<strong>不相交的集合</strong>，并支持两种操作：</p><ul><li><strong>合并</strong>（Union）：把两个不相交的集合合并为一个集合。</li><li><strong>查询</strong>（Find）：查询两个元素是否在同一个集合中。</li></ul><p>并查集的重要思想在于，<strong>用集合中的一个元素代表集合</strong>。</p><p>通俗地讲，将各元素看做一点，有联系的两点之间有通路，最终形成图结构，该图包含一个或多个连通分支。</p><p><img src="/2021/01/11/LeetCode-并查集-交换字符串中的元素/并查集1.jpg" alt="并查集1"></p><p>初始的6个节点。</p><p><img src="/2021/01/11/LeetCode-并查集-交换字符串中的元素/并查集2.jpg" alt="并查集1"></p><p>1与3相关联，建立通路，此时设1为该集合的代表元素。</p><p><img src="/2021/01/11/LeetCode-并查集-交换字符串中的元素/并查集3.jpg" alt="并查集1"></p><p>此时，2与3相关联，2可与3建立通路，也可与1建立通路（只要属于同一集合即可），我们让各自的根节点（代表元素）与代表元素建立通路，即1和2。（为什么取这样后文讨论）</p><p><img src="/2021/01/11/LeetCode-并查集-交换字符串中的元素/并查集4.jpg" alt="并查集1"></p><p>同理，4、5和6相关联，建立通路。</p><p><img src="/2021/01/11/LeetCode-并查集-交换字符串中的元素/并查集5.jpg" alt="并查集1"></p><p>此时，6和3相关联，所以在两个代表元素1和4之间建立通路，取1为代表元素（取4也可，后文讨论）。</p><p><img src="/2021/01/11/LeetCode-并查集-交换字符串中的元素/并查集6.png" alt="并查集1"></p><p>最终得到的结构如图，是一个图结构。由图可知，寻找某个节点的所属的集合只要层层向上访问父节点，直到根节点（代表元素）即可。</p><p>由此，我们可以得出并查集的简单代码：</p><p><strong>初始化</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> father[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">father[i] = i;<span class="comment">//初始各节点的父节点为自己本身</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如有编号为1, 2, 3, …, n的n个元素，我们用一个数组fa[]来存储每个元素的父节点（因为每个元素有且只有一个父节点，所以这是可行的）。一开始，我们先将它们的父节点设为自己。</p><p><strong>查询</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(father[x] == x)</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> find(father[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用递归实现对代表元素的查询：一层一层访问父节点，直至根节点（根节点的标志就是父节点是其本身）。要判断两个元素是否属于同一个集合，只需要看它们的根节点是否相同即可。</p><p><strong>合并</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">fx = find(x);</span><br><span class="line">fy = find(y);</span><br><span class="line">father[fx] = fy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>合并操作即，先找到两个集合的代表元素，然后将前者的父节点设为后者即可。（当然也可以将后者的父节点设为前者，后文讨论。）</p><p>至此，我们得到了并查集的基本操作。</p><h5 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h5><p>上文提到，2与3相关联，2可与3建立通路，也可与1建立通路（只要属于同一集合即可），我们取的与1的通路。假设我们取2与3的通路，则1、2和3之间变为一条单链。同理，4、5、6也是单链。此时，6与3建立通路，整个结构变为6个节点的单链，此时查询根节点的开销随着距离根节点的距离增大逐渐增大。</p><p>但是我们关心的仅为某一元素对应的集合（即根节点），当然希望每个元素到根节点的路径尽可能短，最好只需要一步。</p><p>所以只要在查询的过程中，<strong>把沿途的每个节点的父节点都设为根节点</strong>即可。下一次再查询时，我们就可以节省时间。递归实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == father[x])</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        father[x] = find(father[x]);  <span class="comment">//父节点设为根节点</span></span><br><span class="line">        <span class="keyword">return</span> fa[x];<span class="comment">//返回父节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="按深度合并"><a href="#按深度合并" class="headerlink" title="按深度合并"></a>按深度合并</h5><p>在合并两个树时，如果单纯地将前者合并到后者，容易使得合并后的树结构变复杂。</p><p><img src="/2021/01/11/LeetCode-并查集-交换字符串中的元素/并查集7.jpg" alt="并查集7"></p><p>如图，合并7、8时，会面临两种选择：</p><p><img src="/2021/01/11/LeetCode-并查集-交换字符串中的元素/并查集8.jpg" alt="并查集8"></p><p>很明显选后者。因为如果把7的父节点设为8，会使树的<strong>深度</strong>（树中最长链的长度）加深，原来的树中每个元素到根节点的距离都变长了，之后我们寻找根节点的路径也就会相应变长。虽然我们有路径压缩，但路径压缩也是会消耗时间的。而把8的父节点设为7，则不会有这个问题，因为它没有影响到不相关的节点。</p><p>因此，我们在合并时，<strong>应该把简单的树往复杂的树上合并，而不是相反。因为这样合并后，到根节点距离变长的节点个数比较少。</strong></p><p>用一个数组rank[]记录每个根节点对应的树的深度（如果不是根节点，其rank相当于以它作为根节点的<strong>子树</strong>的深度）。一开始，把所有元素的rank设为1。合并时比较两个根节点，把rank较小者往较大者上合并。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">        rank[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = find(i), y = find(j);    <span class="comment">//先找到两个根节点</span></span><br><span class="line">    <span class="keyword">if</span> (rank[x] &lt;= rank[y])</span><br><span class="line">        fa[x] = y;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        fa[y] = x;</span><br><span class="line">    <span class="keyword">if</span> (rank[x] == rank[y] &amp;&amp; x != y)</span><br><span class="line">        rank[y]++;                   <span class="comment">//如果深度相同且根节点不同，则新的根节点的深度+1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，讨论完了并查集的相关内容。我们回到题目本身。</p><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>学习完并查集相关内容后，思路自然而然地产生了：利用并查集，将s中的字符元素分成多个集合，对每个集合中的元素分别进行排序，插回原字符串即可。</p><p>（此时，单纯的我还不知道自己给自己挖的坑。）</p><p>程序流程如下：</p><p>利用并查集分类 -&gt; 筛选分组 -&gt; 排序 -&gt; 插回。</p><h5 id="代码1-0"><a href="#代码1-0" class="headerlink" title="代码1.0"></a>代码1.0</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    father = []</span><br><span class="line">    rank = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">smallestStringWithSwaps</span><span class="params">(self, s: str, pairs: List[List[int]])</span> -&gt; str:</span></span><br><span class="line">        length = len(s)</span><br><span class="line">        group_dic = &#123;&#125;</span><br><span class="line">        self.init(length)</span><br><span class="line">        <span class="keyword">for</span> pair <span class="keyword">in</span> pairs:</span><br><span class="line">            self.merge(pair[<span class="number">0</span>],pair[<span class="number">1</span>])</span><br><span class="line">        <span class="comment"># 对每一个元素进行分组</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,length):</span><br><span class="line">            x = self.find(i)</span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> group_dic.keys():</span><br><span class="line">                group_dic[x] = [s[i]]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                group_dic[x].append(s[i])</span><br><span class="line">        <span class="comment">#对每一个分组中序号对应的元素组成的逻辑上的数组进行 选择排序</span></span><br><span class="line">        <span class="comment"># 不得不吐槽，这个排序毫无用处还把👴绕晕了</span></span><br><span class="line">        l = list(s)</span><br><span class="line">        <span class="keyword">for</span> group <span class="keyword">in</span> group_dic.values():</span><br><span class="line">            group.sort()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(group)<span class="number">-1</span>):</span><br><span class="line">                m = group[i]</span><br><span class="line">                mini = m</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,len(group)):</span><br><span class="line">                    n = group[j]</span><br><span class="line">                    <span class="keyword">if</span> l[n] &lt; l[mini]:</span><br><span class="line">                        mini = n</span><br><span class="line">                temp = l[m]</span><br><span class="line">                l[m] = l[mini]</span><br><span class="line">                l[mini] = temp</span><br><span class="line">        s = <span class="string">''</span>.join(l)</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        self.father = [<span class="number">0</span>]*n</span><br><span class="line">        self.rank = [<span class="number">1</span>]*n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n):</span><br><span class="line">            self.father[i] = i</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.father[x] == x:</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment">#路径压缩，将父节点设为根节点</span></span><br><span class="line">            self.father[x] = self.find(self.father[x])</span><br><span class="line">            <span class="keyword">return</span> self.father[x]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        father_x = self.find(x)</span><br><span class="line">        father_y = self.find(y)</span><br><span class="line">        <span class="keyword">if</span> father_x != father_y:</span><br><span class="line">            self.father[father_x] = father_y</span><br></pre></td></tr></table></figure><p>debug环节省略，磕磕碰碰把代码写出来，过了test，提交！然后不出意料的，超时了orz</p><p>很明显，选择排序在元素数量多时表现太差了。</p><p>因此换一种思路：既然我已经对元素分好了组，那么我可以在组内进行排序，然后遍历整个字符串，每个位置属于某个分组时，取出该分组中的最小元素填入该位置即可。</p><h5 id="代码1-1"><a href="#代码1-1" class="headerlink" title="代码1.1"></a>代码1.1</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    father = []</span><br><span class="line">    rank = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">smallestStringWithSwaps</span><span class="params">(self, s: str, pairs: List[List[int]])</span> -&gt; str:</span></span><br><span class="line">        length = len(s)</span><br><span class="line">        group_dic = &#123;&#125;</span><br><span class="line">        self.init(length)</span><br><span class="line">        <span class="keyword">for</span> pair <span class="keyword">in</span> pairs:</span><br><span class="line">            self.merge(pair[<span class="number">0</span>],pair[<span class="number">1</span>])</span><br><span class="line">        <span class="comment"># 对每一个元素进行分组</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,length):</span><br><span class="line">            x = self.find(i)</span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> group_dic.keys():</span><br><span class="line">                group_dic[x] = [s[i]]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                group_dic[x].append(s[i])</span><br><span class="line">        <span class="comment">#对于某一集合，逐个取出最小元素</span></span><br><span class="line">        <span class="keyword">for</span> group <span class="keyword">in</span> group_dic.values():</span><br><span class="line">            group.sort()</span><br><span class="line">        l = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,length):</span><br><span class="line">            x = self.find(i)</span><br><span class="line">            l.append(group_dic[x][<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">del</span>(group_dic[x][<span class="number">0</span>])</span><br><span class="line">        s = <span class="string">''</span>.join(l)</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        self.father = [<span class="number">0</span>]*n</span><br><span class="line">        self.rank = [<span class="number">1</span>]*n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n):</span><br><span class="line">            self.father[i] = i</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.father[x] == x:</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment">#路径压缩，将父节点设为根节点</span></span><br><span class="line">            self.father[x] = self.find(self.father[x])</span><br><span class="line">            <span class="keyword">return</span> self.father[x]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        father_x = self.find(x)</span><br><span class="line">        father_y = self.find(y)</span><br><span class="line">        <span class="keyword">if</span> father_x != father_y:</span><br><span class="line">            self.father[father_x] = father_y</span><br></pre></td></tr></table></figure><p>提交代码，终于通过。虽然结果很烂，但是不想改了，打开官方题解研究一下。</p><p><img src="/2021/01/11/LeetCode-并查集-交换字符串中的元素/result.png" alt="result"></p><p><a href="https://leetcode-cn.com/problems/smallest-string-with-swaps/solution/jiao-huan-zi-fu-chuan-zhong-de-yuan-su-b-qdn9/" target="_blank" rel="noopener">官方题解</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#并查集基本操作，没什么好说的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DisjointSetUnion</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n: int)</span>:</span></span><br><span class="line">        self.n = n</span><br><span class="line">        self.rank = [<span class="number">1</span>] * n</span><br><span class="line">        self.f = list(range(n))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, x: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> self.f[x] == x:</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        self.f[x] = self.find(self.f[x])</span><br><span class="line">        <span class="keyword">return</span> self.f[x]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">unionSet</span><span class="params">(self, x: int, y: int)</span>:</span></span><br><span class="line">        fx, fy = self.find(x), self.find(y)</span><br><span class="line">        <span class="keyword">if</span> fx == fy:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> self.rank[fx] &lt; self.rank[fy]:</span><br><span class="line">            fx, fy = fy, fx</span><br><span class="line">        self.rank[fx] += self.rank[fy]</span><br><span class="line">        self.f[fy] = fx</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">smallestStringWithSwaps</span><span class="params">(self, s: str, pairs: List[List[int]])</span> -&gt; str:</span></span><br><span class="line">        dsu = DisjointSetUnion(len(s))</span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> pairs:</span><br><span class="line">            dsu.unionSet(x, y)</span><br><span class="line">        <span class="comment">#这里使用默认返回list的字典，解决了Nonetype不能append的问题（👴遇到了）</span></span><br><span class="line">        mp = collections.defaultdict(list)</span><br><span class="line">        <span class="comment">#这里使用枚举enumerate() 函数，简单方便，👴不会，学到了</span></span><br><span class="line">        <span class="keyword">for</span> i, ch <span class="keyword">in</span> enumerate(s):</span><br><span class="line">            mp[dsu.find(i)].append(ch)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> vec <span class="keyword">in</span> mp.values():</span><br><span class="line">            vec.sort(reverse=<span class="literal">True</span>)</span><br><span class="line">        </span><br><span class="line">        ans = list()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            x = dsu.find(i)</span><br><span class="line">            ans.append(mp[x][<span class="number">-1</span>])</span><br><span class="line">            <span class="comment">#这里使用pop弹出末尾元素，简洁</span></span><br><span class="line">            mp[x].pop()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join(ans)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-3-无重复字符的最长子串</title>
      <link href="/2019/08/03/LeetCode-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
      <url>/2019/08/03/LeetCode-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><a id="more"></a><p>示例 1:</p><blockquote><p>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p></blockquote><p>示例 2:</p><blockquote><p>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p></blockquote><p>示例 3:</p><blockquote><p>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。</p></blockquote><p>请注意，你的答案必须是 <strong>子串</strong> 的长度，”pwke” 是一个子序列，不是子串。</p><p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters" target="_blank" rel="noopener">题目链接</a></p><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><h5 id="暴力求解"><a href="#暴力求解" class="headerlink" title="暴力求解"></a>暴力求解</h5><p>看到题目很容易产生的想法就是对字符串进行遍历，以每个字符为开头，检查所有子串。</p><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="keyword">char</span> * s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,begin = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">0</span>, maxlength = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">'\0'</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; s[i] != <span class="string">'\0'</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = begin; j &lt; i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == s[j])&#123;</span><br><span class="line">                <span class="keyword">if</span>(length &gt; maxlength) maxlength = length;</span><br><span class="line">                length = <span class="number">0</span>;</span><br><span class="line">                i = begin + <span class="number">1</span>;</span><br><span class="line">                begin = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        length += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(length &gt; maxlength) maxlength = length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxlength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="暴力求解时间复杂度分析"><a href="#暴力求解时间复杂度分析" class="headerlink" title="暴力求解时间复杂度分析"></a>暴力求解时间复杂度分析</h5><p>时间复杂度：$O(n^3) $</p><p>要验证索引范围在$ [i, j)$ 内的字符是否都是唯一的，我们需要检查该范围中的所有字符。 因此，它将花费 $O(j−i)$ 的时间。</p><p>对于给定的 i，对于所有 $j \in [i+1, n]$ 所耗费的时间总和为：</p><p>$ \sum_{i+1}^{n}O(j - i)$</p><p>因此，执行所有步骤耗去的时间总和为：</p><p>$ O\left(\sum_{i = 0}^{n - 1}\left(\sum_{j = i + 1}^{n}(j - i)\right)\right) = O\left(\sum_{i = 0}^{n - 1}\frac{(1 + n - i)(n - i)}{2}\right) = O(n^3)$</p><p>由此可见，暴力求解法时间复杂度很大，因此我们需要一种更好的算法来降低时间复杂度。</p><h5 id="滑动窗口法"><a href="#滑动窗口法" class="headerlink" title="滑动窗口法"></a>滑动窗口法</h5><p>滑动窗口通俗来说就是一个队列，以样例<code>abcbcde</code>来说明：刚开始窗口左右端位于字符串开头处的<code>a</code>，此时窗口中没有字符，所以不存在重复，字符<code>a</code>可以进入“队列”，然后窗口的右端开始右移扩大窗口（该窗口为左闭右开，即不包含右端所指向的字符）。当窗口右端移动到第二个<code>b</code>处，此时窗口中为<code>abc</code>，已经包含一个<code>b</code>，发生重复，此时窗口左端开始右移缩小窗口，直至重复字符移出“队列”。重复该过程，直至窗口右端超出字符串。</p><p>在窗口移动时，记录窗口的最长长度，就是我们所要求解的答案。</p><p>因为C语言中没有方便使用的<code>Map</code>，故而使用Python的字典来实现这一算法。</p><p>以下为Python代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        maxLength = <span class="number">0</span></span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(right &lt; len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[right] <span class="keyword">not</span> <span class="keyword">in</span> dic:</span><br><span class="line">                dic[s[right]] = right</span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">del</span> dic[s[left]]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> len(dic) &gt; maxLength:</span><br><span class="line">                maxLength = len(dic)</span><br><span class="line">        <span class="keyword">return</span> maxLength</span><br></pre></td></tr></table></figure><h5 id="滑动窗口法时间复杂度分析"><a href="#滑动窗口法时间复杂度分析" class="headerlink" title="滑动窗口法时间复杂度分析"></a>滑动窗口法时间复杂度分析</h5><p>时间复杂度：$O(2n) = O(n)$，在最糟糕的情况下，每个字符将被窗口左端和右端各访问一次。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在做这道题之前我并不了解滑动窗口算法，只在计算机网络中听过“滑动窗口”这一名词。</p><p>滑动窗口算法适用于很多数组和字符串的子元素问题，将嵌套的循环转换为单循环问题，降低时间复杂度。</p><p>参考资料：<a href="https://www.zhihu.com/question/314669016" target="_blank" rel="noopener">什么是「滑动窗口算法」（sliding window algorithm），有哪些应用场景？</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 字符串 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-2-两数相加</title>
      <link href="/2019/08/02/LeetCode-2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
      <url>/2019/08/02/LeetCode-2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
      
        <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给出两个<strong>非空</strong>的链表用来表示两个非负的整数。其中，它们各自的位数是按照<strong>逆序</strong>的方式存储的，并且它们的每个节点只能存储<strong>一位</strong>数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><a id="more"></a><blockquote><p>示例：</p><p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p></blockquote><p><a href="https://leetcode-cn.com/problems/add-two-numbers" target="_blank" rel="noopener">题目链接</a></p><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><h5 id="初步解法"><a href="#初步解法" class="headerlink" title="初步解法"></a>初步解法</h5><p>刚一看到题目就想到了第一种思路：首先根据两个链表读出其中的数据，对两个数据求和，然后通过模和除求出和的每一位数字，建立新链表。</p><p>代码很快就写好了，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">addTwoNumbers</span><span class="params">(struct ListNode* l1, struct ListNode* l2)</span></span>&#123;</span><br><span class="line">    <span class="comment">//求和</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">l</span> = <span class="title">l1</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sum = <span class="number">0</span>,val;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(count&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> order = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            sum += (<span class="keyword">int</span>)((l-&gt;val)*<span class="built_in">pow</span>(<span class="number">10.0</span>,(<span class="keyword">double</span>)order));</span><br><span class="line">            l = l-&gt;next;</span><br><span class="line">            order += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">        l = l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分解所得和并建立新链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">result</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">newNode1</span> = (<span class="title">struct</span> <span class="title">ListNode</span> *) <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    newNode1-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    result = newNode1;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        val = sum % <span class="number">10</span>;</span><br><span class="line">        sum = sum / <span class="number">10</span>;</span><br><span class="line">        newNode1-&gt;val = val;</span><br><span class="line">        <span class="keyword">if</span>(sum != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">newNode2</span> = (<span class="title">struct</span> <span class="title">ListNode</span> *) <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">            newNode2-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            newNode1-&gt;next = newNode2;</span><br><span class="line">            newNode1 = newNode2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="初步解法遇到的问题"><a href="#初步解法遇到的问题" class="headerlink" title="初步解法遇到的问题"></a>初步解法遇到的问题</h5><p>代码运行成功解出样例，但是提交发现，测试所给数据位数很多，数据很大，求和后会溢出，即使改用<code>long</code>类型依然无法补救，故初步解法扑街。</p><h5 id="进阶解法"><a href="#进阶解法" class="headerlink" title="进阶解法"></a>进阶解法</h5><p>既然初步解法没用，只能换一种思路。想到以前学过的链表合并算法，可以借鉴一波。</p><p>新思路：因为两个链表从头结点开始，每个对应的结点都是相同位上的数字（个十百千），所以从头结点开始，两个结点相加，求出该位数字，并记录进位，相应的，也要记录前一位给当前位的进位。当某一链表结束之后，剩下的位取没结束的那个链表（此处别忘记前一位的进位）。</p><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">addTwoNumbers</span><span class="params">(struct ListNode* l1, struct ListNode* l2)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">n1</span> = <span class="title">l1</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">n2</span> = <span class="title">l2</span>;</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;<span class="comment">//本位和</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//给下一位的进位</span></span><br><span class="line">    <span class="keyword">int</span> precount = <span class="number">0</span>;<span class="comment">//前一位的进位</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">result</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">newNode1</span> = (<span class="title">struct</span> <span class="title">ListNode</span> *) <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    newNode1-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    result = newNode1;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        precount = count;<span class="comment">//更新前一位的进位</span></span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//两链表都不空时</span></span><br><span class="line">        <span class="keyword">if</span>(n1 != <span class="literal">NULL</span> &amp;&amp; n2 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            sum = n1-&gt;val + n2-&gt;val + precount;</span><br><span class="line">            <span class="keyword">if</span>(sum &gt; <span class="number">9</span>)&#123;</span><br><span class="line">                sum -= <span class="number">10</span>;</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            n1 = n1-&gt;next;</span><br><span class="line">            n2 = n2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//单一链表为空时</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n1 == <span class="literal">NULL</span> &amp;&amp; n2 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            sum = n2-&gt;val + precount;</span><br><span class="line">            <span class="keyword">if</span>(sum &gt; <span class="number">9</span>)&#123;</span><br><span class="line">                sum -= <span class="number">10</span>;</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            n2 = n2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n2 == <span class="literal">NULL</span> &amp;&amp; n1 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            sum = n1-&gt;val + precount;</span><br><span class="line">            <span class="keyword">if</span>(sum &gt; <span class="number">9</span>)&#123;</span><br><span class="line">                sum -= <span class="number">10</span>;</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            n1 = n1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        newNode1-&gt;val = sum;</span><br><span class="line">        <span class="comment">//两链表同为空</span></span><br><span class="line">        <span class="keyword">if</span>(n1 == <span class="literal">NULL</span> &amp;&amp; n2 == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="comment">//此时不能忘记前面的进位</span></span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">newNode2</span> = (<span class="title">struct</span> <span class="title">ListNode</span> *) <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">                newNode2-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">                newNode1-&gt;next = newNode2;</span><br><span class="line">                newNode1 = newNode2;</span><br><span class="line">                newNode1-&gt;val = count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">newNode2</span> = (<span class="title">struct</span> <span class="title">ListNode</span> *) <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">        newNode2-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        newNode1-&gt;next = newNode2;</span><br><span class="line">        newNode1 = newNode2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该代码提交成功，并击败约98%的人。</p><h5 id="进阶解法踩到的坑"><a href="#进阶解法踩到的坑" class="headerlink" title="进阶解法踩到的坑"></a>进阶解法踩到的坑</h5><ul><li>两链表都结束后，要考虑到最后的进位，可能后面还有一位数，例如：9 + 991 = 1000</li><li>检测到两链表同时结束后，此时应该看的进位变量应为<code>count</code>，而不是<code>precount</code>，因为还没到下一节点</li><li>不要忘记让节点指向<code>next</code>，否则会死循环</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>该题目未给出数据取值范围，所以会出现第一种解法。</li><li>这道题目考察链表的有关内容（参见数据结构），涉及到链表的合并、建立等。</li><li>做这道题目莫名地想到了“大数相乘”的求解，以后有机会补充一下。</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-1-两数之和</title>
      <link href="/2019/08/01/LeetCode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/2019/08/01/LeetCode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的那<strong>两个</strong>整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><a id="more"></a><p>示例:</p><blockquote><p>给定 nums = [2, 7, 11, 15], target = 9</p><p>因为 nums[0] + nums[1] = 2 + 7 = 9</p><p>所以返回 [0, 1]</p></blockquote><p><a href="https://leetcode-cn.com/problems/two-sum" target="_blank" rel="noopener">题目链接</a></p><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><h5 id="初步解法"><a href="#初步解法" class="headerlink" title="初步解法"></a>初步解法</h5><p>刚看到题目，第一反应是暴力求解，即类似于选择排序的算法，从头开始利用每个值与其后的值逐个判断。这种方法思路简单，但时间复杂度高，为 $ O(n^2)$ </p><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">twoSum</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target, <span class="keyword">int</span>* returnSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">int</span>* two_nums = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;numsSize<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;numsSize;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]+nums[j] == target)&#123;</span><br><span class="line">                two_nums[<span class="number">0</span>] = i;</span><br><span class="line">                two_nums[<span class="number">1</span>] = j;</span><br><span class="line">                *returnSize = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">return</span> two_nums;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="踩到的坑"><a href="#踩到的坑" class="headerlink" title="踩到的坑"></a>踩到的坑</h5><p>最开始以为<code>returnSize</code>是结果数组，所以用<code>malloc()</code>为它申请了内存空间，然后运行一直报错。然后根据字面意思和提交结果，猜测这个参数是一地址传递的参数，在主函数内控制输出个数。（因为之前输出结果一直为空）所以在找到结果时将其改写为2，另外申请一块内存存储结果。</p><h5 id="解法进阶"><a href="#解法进阶" class="headerlink" title="解法进阶"></a>解法进阶</h5><p>思路：用Hash表的形式存储数据，用空间复杂度换时间复杂度。</p><p>引用LeetCode上的一个解的代码：</p><p><a href="https://leetcode-cn.com/problems/two-sum/solution/cyu-yan-yi-bian-ha-xi-kong-jian-onhuan-shi-jian-on/" target="_blank" rel="noopener">代码链接</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hash_node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;            <span class="comment">/* we'll use this field as the key */</span></span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    UT_hash_handle hh; <span class="comment">/* makes this structure hashable */</span></span><br><span class="line">&#125; hash_node;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">twoSum</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target, <span class="keyword">int</span>* returnSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *two_nums = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">2</span>);</span><br><span class="line">    hash_node *hash_table = <span class="literal">NULL</span>, *hash_item1 = <span class="literal">NULL</span>, *hash_item2 = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        <span class="comment">// 查找哈希表中是否存在满足和为target的另一个值,若存在直接返回</span></span><br><span class="line">        <span class="keyword">int</span> other_id = target - *(nums+i);</span><br><span class="line">        HASH_FIND_INT(hash_table, &amp;other_id, hash_item1);</span><br><span class="line">        <span class="keyword">if</span> (hash_item1) &#123;</span><br><span class="line">            two_nums[<span class="number">0</span>] = hash_item1-&gt;index;</span><br><span class="line">            two_nums[<span class="number">1</span>] = i;</span><br><span class="line">            *returnSize = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> two_nums;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将本次遍历的值放入哈希表,value为数组下标,key为对应数值</span></span><br><span class="line">        hash_item2 = (hash_node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(hash_node));</span><br><span class="line">        hash_item2-&gt;id = *(nums+i);</span><br><span class="line">        hash_item2-&gt;index = i;</span><br><span class="line">        HASH_ADD_INT(hash_table, id, hash_item2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> two_nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>HASH_FIND_INT()、HASH_ADD_INT()</code>等函数是来自C语言的一个开源库 <a href="https://troydhanson.github.io/uthash/" target="_blank" rel="noopener"><code>uthash</code></a></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>这道题考察的内容不多，包括一些C语言中的指针的使用，<code>malloc()</code>函数的使用等。</li><li>使用哈希表来存储并重复查找数据，可以大幅降低时间复杂度，但会增大空间复杂度。</li><li>这是我第一次在C语言中使用哈希表，还需要使用外部库。如果是在Python中，可以利用字典这一数据结构，使用起来更方便。</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录几个Linux下文件比较工具</title>
      <link href="/2019/05/17/%E8%AE%B0%E5%BD%95%E5%87%A0%E4%B8%AALinux%E4%B8%8B%E6%96%87%E4%BB%B6%E6%AF%94%E8%BE%83%E5%B7%A5%E5%85%B7/"/>
      <url>/2019/05/17/%E8%AE%B0%E5%BD%95%E5%87%A0%E4%B8%AALinux%E4%B8%8B%E6%96%87%E4%BB%B6%E6%AF%94%E8%BE%83%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<p>简略记录Linux下用来比较文件异同的命令工具。</p><a id="more"></a><p>cmp 比较两个文件，并指出它们是否不同及不同的字节。</p><p>diff 比较两个文件或目录，并指出哪些文件的哪些行不同。</p><p>diff3 逐行比较三个文件。</p><p>sdiff 合并两个文件，并以交互方式输出结果。</p><p>vimdiff 使用vim同时编辑一个文档的2或3个版本并显示他们的区别使用。</p><p>comm 一行一行对两个已经排序的文件进行比较，在第三列中显示同一行是否相同。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中文分词实验及FMM与BMM算法实现</title>
      <link href="/2019/05/03/%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E5%AE%9E%E9%AA%8C%E5%8F%8AFMM%E4%B8%8EBMM%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/05/03/%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E5%AE%9E%E9%AA%8C%E5%8F%8AFMM%E4%B8%8EBMM%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>此为在课上做的一个实验，涉及内容较多故做如下记录。</p><p>主要分为三部分：实现中文分词、实现FMM算法、实现BMM算法</p><a id="more"></a><h4 id="中文分词"><a href="#中文分词" class="headerlink" title="中文分词"></a>中文分词</h4><h5 id="基本要求"><a href="#基本要求" class="headerlink" title="基本要求"></a>基本要求</h5><p>给定语料库，从中识别中文分词并统计词频。</p><p>语料库示例：</p><p>19980101-01-001-001/m  迈向/v  充满/v  希望/n  的/u  新/a  世纪/n  ——/w  一九九八年/t  新年/t  讲话/n  （/w  附/v  图片/n  １/m  张/q  ）/w  </p><p>19980101-01-001-006/m  在/p  １９９８年/t  来临/v  之际/f  ，/w  我/r  十分/m  高兴/a  地/u  通过/p  [中央/n  人民/n  广播/vn  电台/n]nt  、/w  [中国/ns  国际/n  广播/vn  电台/n]nt  和/c  [中央/n  电视台/n]nt  ，/w  向/p  全国/n  各族/r  人民/n  ，/w  向/p  [香港/ns  特别/a  行政区/n]ns  同胞/n  、/w  澳门/ns  和/c  台湾/ns  同胞/n  、/w  海外/s  侨胞/n  ，/w  向/p  世界/n  各国/r  的/u  朋友/n  们/k  ，/w  致以/v  诚挚/a  的/u  问候/vn  和/c  良好/a  的/u  祝愿/vn  ！/w  </p><p>结果示例：</p><p>民心所向:1<br>实劲:1<br>音乐声:1</p><p>……</p><p>。:35983<br>的:54487<br>，:74921</p><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addtodic</span><span class="params">(dic,s)</span>:</span></span><br><span class="line"><span class="keyword">if</span> dic. __contains__(s):</span><br><span class="line">dic[s] += <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">dic[s] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(dic,data)</span>:</span></span><br><span class="line">    <span class="comment">#识别普通分词</span></span><br><span class="line">pattern1 = <span class="string">u'[\u0080-\uFFFD0-9\-]+'</span></span><br><span class="line">p = re.compile(pattern1)</span><br><span class="line">l = p.findall(data)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> l:</span><br><span class="line">        <span class="comment">#去掉时间</span></span><br><span class="line"><span class="keyword">if</span> re.match(<span class="string">r"[0-9]+-[0-9]+-"</span>,i):</span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">addtodic(dic,i)</span><br><span class="line"></span><br><span class="line"><span class="comment">#识别形如[.*]的分词</span></span><br><span class="line">l = []</span><br><span class="line">temp = []</span><br><span class="line">pattern2 = <span class="string">u'\[[\u0080-\uFFFD\u0020/0-9\w]+\]?'</span></span><br><span class="line">p = re.compile(pattern2)</span><br><span class="line">l = p.findall(data)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> l:</span><br><span class="line">temp = re.compile(pattern1).findall(i)</span><br><span class="line">s = <span class="string">""</span>.join(i <span class="keyword">for</span> i <span class="keyword">in</span> temp)</span><br><span class="line">addtodic(dic,s)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">file = open(<span class="string">"./ylk.txt"</span>,<span class="string">'r'</span>,encoding = <span class="string">"utf-8"</span>)</span><br><span class="line">data = file.read()</span><br><span class="line">data = data[<span class="number">3</span>:]</span><br><span class="line">dic = &#123;&#125;</span><br><span class="line">create(dic,data)</span><br><span class="line">l = sorted(dic.items(),key = <span class="keyword">lambda</span> item:item[<span class="number">1</span>])</span><br><span class="line">outfile = open(<span class="string">'./dic.txt'</span>,<span class="string">'w'</span>)</span><br><span class="line">print(len(l))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> l:</span><br><span class="line">s = <span class="string">""</span>+i[<span class="number">0</span>]+<span class="string">":"</span>+str(i[<span class="number">1</span>])+<span class="string">"\n"</span></span><br><span class="line">outfile.write(s)</span><br><span class="line">print(s)</span><br><span class="line"><span class="comment">#break</span></span><br><span class="line">outfile.close()</span><br></pre></td></tr></table></figure><h5 id="补充：Unicode中文编码范围："><a href="#补充：Unicode中文编码范围：" class="headerlink" title="补充：Unicode中文编码范围："></a>补充：Unicode中文编码范围：</h5><p>2E80～33FFh：中日韩符号区。收容康熙字典部首、中日韩辅助部首、注音符号、日本假名、韩文音符，中日韩的符号、标点、带圈或带括符文数字、月份，以及日本的假名组合、单位、年号、月份、日期、时间等。<br>3400～4DFFh：中日韩认同表意文字扩充A区，总计收容6,582个中日韩汉字。<br>4E00～9FFFh：中日韩认同表意文字区，总计收容20,902个中日韩汉字。<br>A000～A4FFh：彝族文字区，收容中国南方彝族文字和字根。<br>AC00～D7FFh：韩文拼音组合字区，收容以韩文音符拼成的文字。<br>F900～FAFFh：中日韩兼容表意文字区，总计收容302个中日韩汉字。<br>FB00～FFFDh：文字表现形式区，收容组合拉丁文字、希伯来文、阿拉伯文、中日韩直式标点、小符号、半角符号、全角符号等。</p><h4 id="FMM算法实现"><a href="#FMM算法实现" class="headerlink" title="FMM算法实现"></a>FMM算法实现</h4><h5 id="FMM简介"><a href="#FMM简介" class="headerlink" title="FMM简介"></a>FMM简介</h5><p>FMM即正向最大匹配分词，即每次向后读取maxWordLength个字，如若匹配则继续，否则回退一个字继续匹配，直至单字无法匹配，将其单独分词。经统计，示例单词本中的maxWordLength为32。</p><h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fmm</span><span class="params">(sentence,dic)</span>:</span></span><br><span class="line">    sentence = sentence.strip(<span class="string">"\n"</span>)</span><br><span class="line">    result = <span class="string">""</span></span><br><span class="line">    succ = <span class="number">0</span></span><br><span class="line">    maxlength = <span class="number">32</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> len(sentence) <span class="keyword">is</span> <span class="number">0</span>:</span><br><span class="line">        temp_s = sentence[:maxlength]</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> dic.__contains__(temp_s):</span><br><span class="line">            <span class="keyword">if</span> len(temp_s) &gt; <span class="number">1</span>:</span><br><span class="line">                temp_s = temp_s[:<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        result += temp_s+<span class="string">'/'</span></span><br><span class="line">        sentence = sentence[len(temp_s):]</span><br></pre></td></tr></table></figure><h5 id="分词结果"><a href="#分词结果" class="headerlink" title="分词结果"></a>分词结果</h5><p>祝愿/祖国/明天/更加/繁荣昌盛/香港/大学生/在/京/度/佳节/新华社/北京/１月/１日/电/昨晚/，/第一/次/来到/首都/北京/的/５０/多/名/香港/大学生/，/和/北京航空航天大学/的/同学/们/在/《/歌唱/祖国/》/的/歌声/中/一起/迎接/１９９８年/的/到来/。/此次/到/京/的/香港/大学生/来自/香港科技大学/和/浸会大学/，/他们/于/１２月/３０日/抵京/后/参观/了/北大/、/清华/和/抗日战争纪念馆/。/在/中国青年政治学院/，/两地/大学生/就学/习/、/生活/等/共同/关心/的话/题/展开/了/交流/。/</p><h4 id="BMM算法实现"><a href="#BMM算法实现" class="headerlink" title="BMM算法实现"></a>BMM算法实现</h4><h5 id="BMM简介"><a href="#BMM简介" class="headerlink" title="BMM简介"></a>BMM简介</h5><p>BMM即反向最大匹配分词，每次从句尾向前读取maxWordLength个字，如若匹配则继续，否则去掉最左侧单字继续匹配，直至单字无法匹配，将其单独分词。</p><h5 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bmm</span><span class="params">(sentence,dic)</span>:</span></span><br><span class="line">    sentence = sentence.strip(<span class="string">"\n"</span>)</span><br><span class="line">    result = []</span><br><span class="line">    succ = <span class="number">0</span></span><br><span class="line">    maxlength = <span class="number">32</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> len(sentence) <span class="keyword">is</span> <span class="number">0</span>:</span><br><span class="line">        temp_s = sentence[len(sentence)-maxlength:]</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> dic.__contains__(temp_s):</span><br><span class="line">            <span class="keyword">if</span> len(temp_s) &gt; <span class="number">1</span>:</span><br><span class="line">                temp_s = temp_s[<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        result.append(temp_s)</span><br><span class="line">        sentence = sentence[:len(sentence)-len(temp_s)]</span><br><span class="line">    res = <span class="string">""</span>.join(s+<span class="string">'/'</span> <span class="keyword">for</span> s <span class="keyword">in</span> reversed(result))</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h5 id="分词结果-1"><a href="#分词结果-1" class="headerlink" title="分词结果"></a>分词结果</h5><p>祝愿/祖国/明天/更加/繁荣昌盛/香港/大学生/在/京/度/佳节/新华社/北京/１月/１日/电/昨晚/，/第一/次/来到/首都/北京/的/５０/多/名/香港/大学生/，/和/北京航空航天大学/的/同学/们/在/《/歌唱/祖国/》/的/歌声/中/一起/迎接/１９９８年/的/到来/。/此次/到/京/的/香港/大学生/来自/香港科技大学/和/浸会大学/，/他们/于/１/２月/３０日/抵京/后/参观/了/北大/、/清华/和/抗日战争纪念馆/。/在/中国青年政治学院/，/两地/大学生/就/学习/、/生活/等/共同/关心/的/话题/展开/了/交流/。/</p><h4 id="两种算法的分词结果比较"><a href="#两种算法的分词结果比较" class="headerlink" title="两种算法的分词结果比较"></a>两种算法的分词结果比较</h4><p>FMM与BMM分词结果不完全相同，比如例句：</p><p>​    对于两地大学生就学习、生活等共同关心的话题展开了交流。</p><p>FMM分词结果为：</p><p>​    /两地/大学生/就学/习/、/生活/等/共同/关心/的话/题/展开/了/交流/。/</p><p>BMM分词结果为：</p><p>​    /两地/大学生/就/学习/、/生活/等/共同/关心/的/话题/展开/了/交流/。/</p><p>从语义来说，BMM分词更为准确。</p>]]></content>
      
      
      <categories>
          
          <category> 数字内容安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unicode </tag>
            
            <tag> 中文字符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>位图文件的读取与显示</title>
      <link href="/2019/03/24/%E4%BD%8D%E5%9B%BE%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%8F%96%E4%B8%8E%E6%98%BE%E7%A4%BA/"/>
      <url>/2019/03/24/%E4%BD%8D%E5%9B%BE%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%8F%96%E4%B8%8E%E6%98%BE%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<h4 id="要求："><a href="#要求：" class="headerlink" title="要求："></a>要求：</h4><p>通过代码实现位图的显示与修改。</p><p>位图显示：首先，通过代码实现文件的读取，按照前面给定的格式解析文件内容，将解析出的颜色显示在对应的坐标当中。</p><p>位图修改：将像素点中所有的黑色像素修改成（0,0,255），并进行显示和保存。</p><p>编程语言不限，但是不可以使用任何针对图像处理的库函数（OpenCV、PIL等），必须直接读取二进制文件，按照给定的格式进行解析。</p><a id="more"></a><h4 id="位图文件格式说明"><a href="#位图文件格式说明" class="headerlink" title="位图文件格式说明"></a>位图文件格式说明</h4><p>位图文件格式由四部分组成，如图 1所示，分别是<strong>位图文件头</strong>、<strong>位图信息头</strong>、<strong>调色板</strong>以及<strong>位图像素数据</strong>，其中调色板信息为可选信息，只有当每个像素的比特数小于或等于8（BITMAPINFOHEADER.biBitCount&lt;=8）时才存在，即为一个颜色查找表。</p><p>需要注意的是，位图文件存储时为了提高内存访问的速度，每一行的字节数必须是4的倍数，即：如果一幅图像的宽度为253，每个像素用8bit表示，因此，该图像实际每行所占的存储空间数为253Byte，但为了与4对齐，存储时所用的存储空间为256Byte。具体而言，假设图像的宽度为w，每个像素用n比特表示，则图像每行像素所占的字节数为：</p><p>​            (w <em> n + 31)/32 </em> 4</p><p><img src="/2019/03/24/位图文件的读取与显示/结构.png" alt="结构"></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义三个文件头</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tagBITMAPFILEHEADER</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_init_</span><span class="params">(self)</span>:</span></span><br><span class="line">self.bfType = <span class="number">0</span></span><br><span class="line">self.bfsize = <span class="number">0</span></span><br><span class="line">self.bfReserved1 = <span class="number">0</span></span><br><span class="line">self.bfReserved2 = <span class="number">0</span></span><br><span class="line">self.bfOffBits = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tagBITMAPINFOHEADER</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_init_</span><span class="params">(self)</span>:</span></span><br><span class="line">self.biSize = <span class="number">0</span></span><br><span class="line">self.biWidth = <span class="number">0</span></span><br><span class="line">self.biHeight = <span class="number">0</span></span><br><span class="line">self.biPlanes = <span class="number">1</span></span><br><span class="line">self.biBitCount = <span class="number">0</span></span><br><span class="line">self.biCompression = <span class="number">0</span></span><br><span class="line">self.biSizeImage = <span class="number">0</span></span><br><span class="line">self.biXPelsPerMeter = <span class="number">0</span></span><br><span class="line">self.biYPelsPerMeter = <span class="number">0</span></span><br><span class="line">self.BiClrUsed = <span class="number">0</span></span><br><span class="line">self.bClrImportant = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tagRGBQUAD</span><span class="params">()</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_init_</span><span class="params">(self)</span>:</span></span><br><span class="line">self.rgbBlue = <span class="number">0</span></span><br><span class="line">self.rgbGreen = <span class="number">0</span></span><br><span class="line">self.rgbRed = <span class="number">0</span></span><br><span class="line">self.rbgReserved = <span class="number">0</span></span><br><span class="line"><span class="comment">#定义RGB结构体</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">rgb</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_init_</span><span class="params">(self)</span>:</span></span><br><span class="line">self.R = <span class="number">0</span></span><br><span class="line">self.G = <span class="number">0</span></span><br><span class="line">self.B = <span class="number">0</span></span><br><span class="line"><span class="comment">#读取bmp图片</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_bmp</span><span class="params">(file,BITMAPFILEHEADER,BITMAPINFOHEADER,imageData)</span>:</span></span><br><span class="line"><span class="comment">#读文件头</span></span><br><span class="line">fileHeader = file.read(<span class="number">14</span>)</span><br><span class="line">BITMAPFILEHEADER.bfType = struct.unpack(<span class="string">"&lt;H"</span>, fileHeader[:<span class="number">2</span>])[<span class="number">0</span>]</span><br><span class="line">BITMAPFILEHEADER.bfsize = struct.unpack(<span class="string">"&lt;I"</span>, fileHeader[<span class="number">2</span>:<span class="number">6</span>])[<span class="number">0</span>]</span><br><span class="line">BITMAPFILEHEADER.bfReserved1 = struct.unpack(<span class="string">"&lt;H"</span>, fileHeader[<span class="number">6</span>:<span class="number">8</span>])[<span class="number">0</span>]</span><br><span class="line">BITMAPFILEHEADER.bfReserved2 = struct.unpack(<span class="string">"&lt;H"</span>, fileHeader[<span class="number">8</span>:<span class="number">10</span>])[<span class="number">0</span>]</span><br><span class="line">BITMAPFILEHEADER.bfOffBits = struct.unpack(<span class="string">"&lt;I"</span>, fileHeader[<span class="number">10</span>:<span class="number">14</span>])[<span class="number">0</span>]</span><br><span class="line"><span class="comment">#读信息头</span></span><br><span class="line">infoHeader = file.read(<span class="number">40</span>)</span><br><span class="line">BITMAPINFOHEADER.biSize = struct.unpack(<span class="string">"&lt;I"</span>, infoHeader[:<span class="number">4</span>])[<span class="number">0</span>]</span><br><span class="line">BITMAPINFOHEADER.biWidth = struct.unpack(<span class="string">"&lt;L"</span>, infoHeader[<span class="number">4</span>:<span class="number">8</span>])[<span class="number">0</span>]</span><br><span class="line">BITMAPINFOHEADER.biHeight = struct.unpack(<span class="string">"&lt;L"</span>, infoHeader[<span class="number">8</span>:<span class="number">12</span>])[<span class="number">0</span>]</span><br><span class="line">BITMAPINFOHEADER.biPlanes = struct.unpack(<span class="string">"&lt;H"</span>, infoHeader[<span class="number">12</span>:<span class="number">14</span>])[<span class="number">0</span>]</span><br><span class="line">BITMAPINFOHEADER.biBitCount = struct.unpack(<span class="string">"&lt;H"</span>, infoHeader[<span class="number">14</span>:<span class="number">16</span>])[<span class="number">0</span>]</span><br><span class="line">BITMAPINFOHEADER.biCompression = struct.unpack(<span class="string">"&lt;I"</span>, infoHeader[<span class="number">16</span>:<span class="number">20</span>])[<span class="number">0</span>]</span><br><span class="line">BITMAPINFOHEADER.biSizeImage = struct.unpack(<span class="string">"&lt;I"</span>, infoHeader[<span class="number">20</span>:<span class="number">24</span>])[<span class="number">0</span>]</span><br><span class="line">BITMAPINFOHEADER.biXPelsPerMeter = struct.unpack(<span class="string">"&lt;L"</span>, infoHeader[<span class="number">24</span>:<span class="number">28</span>])[<span class="number">0</span>]</span><br><span class="line">BITMAPINFOHEADER.biYPelsPerMeter = struct.unpack(<span class="string">"&lt;L"</span>, infoHeader[<span class="number">28</span>:<span class="number">32</span>])[<span class="number">0</span>]</span><br><span class="line">BITMAPINFOHEADER.BiClrUsed = struct.unpack(<span class="string">"&lt;I"</span>, infoHeader[<span class="number">32</span>:<span class="number">36</span>])[<span class="number">0</span>]</span><br><span class="line">BITMAPINFOHEADER.bClrImportant = struct.unpack(<span class="string">"&lt;I"</span>, infoHeader[<span class="number">36</span>:<span class="number">40</span>])[<span class="number">0</span>]</span><br><span class="line"><span class="comment">#读像素点</span></span><br><span class="line"><span class="comment">#if BITMAPINFOHEADER.biBitCount is 24:</span></span><br><span class="line">num = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,BITMAPINFOHEADER.biHeight*BITMAPINFOHEADER.biWidth):</span><br><span class="line">s = file.read(<span class="number">3</span>)</span><br><span class="line">num += <span class="number">1</span></span><br><span class="line">RGB = rgb()</span><br><span class="line">RGB.R = struct.unpack(<span class="string">"&lt;B"</span>, s[<span class="number">0</span>])[<span class="number">0</span>]</span><br><span class="line">RGB.G = struct.unpack(<span class="string">"&lt;B"</span>, s[<span class="number">1</span>])[<span class="number">0</span>]</span><br><span class="line">RGB.B = struct.unpack(<span class="string">"&lt;B"</span>, s[<span class="number">2</span>])[<span class="number">0</span>]</span><br><span class="line"><span class="comment">#print RGB.R,RGB.G,RGB.B</span></span><br><span class="line">imageData.append(RGB)</span><br><span class="line"><span class="keyword">if</span> num % BITMAPINFOHEADER.biWidth <span class="keyword">is</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">if</span> (num*<span class="number">3</span>)%<span class="number">4</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="number">0</span>:</span><br><span class="line">s = file.read( <span class="number">4</span> - ((num*<span class="number">3</span>)%<span class="number">4</span> ))</span><br><span class="line">num = <span class="number">0</span></span><br><span class="line"><span class="comment">#修改像素点</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bmp_modify</span><span class="params">(imageData)</span>:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> imageData:</span><br><span class="line"><span class="keyword">if</span> i.R &lt; <span class="number">40</span> <span class="keyword">and</span> i.G &lt; <span class="number">40</span> <span class="keyword">and</span> i.B &lt; <span class="number">40</span>:</span><br><span class="line">i.R = <span class="number">0</span></span><br><span class="line">i.G = <span class="number">0</span></span><br><span class="line">i.B = <span class="number">255</span></span><br><span class="line"><span class="comment">#将像素点写入文件</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">writeFile</span><span class="params">(imageData,file,width)</span>:</span></span><br><span class="line">num = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> imageData:</span><br><span class="line">b = struct.pack(<span class="string">"&lt;BBB"</span>,i.R,i.G,i.B)</span><br><span class="line">file.write(b)</span><br><span class="line">num += <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> num % width <span class="keyword">is</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">if</span> (num*<span class="number">3</span>)%<span class="number">4</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="number">0</span>:</span><br><span class="line">file.write((<span class="number">4</span>- (num*<span class="number">3</span>)%<span class="number">4</span> ) * <span class="string">'a'</span>)</span><br><span class="line">num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"><span class="comment">#存取文件头及像素点</span></span><br><span class="line">BITMAPFILEHEADER = tagBITMAPFILEHEADER()</span><br><span class="line">BITMAPINFOHEADER = tagBITMAPINFOHEADER()</span><br><span class="line">imageData = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">r'./logo.bmp'</span>,<span class="string">'rb'</span>) <span class="keyword">as</span> file:</span><br><span class="line">read_bmp(file,BITMAPFILEHEADER,BITMAPINFOHEADER,imageData)</span><br><span class="line"></span><br><span class="line"><span class="comment">#读出宽度，写入时使用</span></span><br><span class="line">width = BITMAPINFOHEADER.biWidth</span><br><span class="line"><span class="comment">#查找符合条件的点</span></span><br><span class="line">bmp_modify(imageData)</span><br><span class="line"><span class="comment">#写入新文件</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">r'./logo.bmp'</span>,<span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">header = f.read(<span class="number">54</span>)</span><br><span class="line">file = open(<span class="string">"./modify.bmp"</span>,<span class="string">'wb'</span>)</span><br><span class="line">file.write(header)</span><br><span class="line">writeFile(imageData,file,width)</span><br><span class="line">file.close()</span><br><span class="line"><span class="comment">#展示新文件</span></span><br><span class="line">im = Image.open(<span class="string">'./modify.bmp'</span>)</span><br><span class="line">im.show()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数字内容安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 位图文件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>N-puzzle(1)</title>
      <link href="/2019/03/24/N-puzzle-1/"/>
      <url>/2019/03/24/N-puzzle-1/</url>
      
        <content type="html"><![CDATA[<h4 id="分别生成8，15，24-Puzzle的可解初始状态各1000个（各不相同）"><a href="#分别生成8，15，24-Puzzle的可解初始状态各1000个（各不相同）" class="headerlink" title="分别生成8，15，24-Puzzle的可解初始状态各1000个（各不相同）"></a>分别生成8，15，24-Puzzle的可解初始状态各1000个（各不相同）</h4><p>要求：</p><p>a)使用扑克牌的洗牌策略生成状态</p><p>b)使用Zobrist Hashing构造Hash表，以判断新生成的状态是否已经存在</p><p>c)各取3个初始状态，打印该状态及其后续状态。空格处用#表示，个位数中间对齐，两位数左对齐。</p><a id="more"></a><p><img src="/2019/03/24/N-puzzle-1/QQ截图20190324143721.png" alt="输出示例"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//package n_puzzle;</span></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">N_puzzle</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Scanner scan;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line"><span class="comment">//输入N-puzzle的N</span></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line">scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">N = scan.nextInt();</span><br><span class="line"><span class="comment">//生成（N+1）的棋盘</span></span><br><span class="line">create(N+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] board = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"><span class="keyword">int</span> i,j,temp;</span><br><span class="line"><span class="keyword">int</span> rand;</span><br><span class="line"><span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line">HashSet&lt;Integer&gt; hs = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line"><span class="keyword">int</span>[][] table = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];<span class="comment">//存放每种状态对应的随机数</span></span><br><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">board[i] = i;<span class="comment">//棋盘初值</span></span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">table[i][j] = random.nextInt();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Zobrist Hashing生成hash初始串</span></span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">hash ^= table[j][board[j]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span>;<span class="comment">//计数生成的状态数</span></span><br><span class="line"><span class="comment">//随机洗牌生成不同状态</span></span><br><span class="line"><span class="keyword">while</span>(i &lt; <span class="number">1003</span>)&#123;<span class="comment">//状态数</span></span><br><span class="line"></span><br><span class="line">temp = board[<span class="number">0</span>];</span><br><span class="line">rand = random.nextInt(n);</span><br><span class="line"><span class="comment">//减去要修改的位置的hash</span></span><br><span class="line">hash ^= table[<span class="number">0</span>][board[<span class="number">0</span>]];</span><br><span class="line">hash ^= table[rand][board[rand]];</span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line">board[<span class="number">0</span>] = board[rand];</span><br><span class="line">board[rand] = temp;</span><br><span class="line"><span class="comment">//加上修改过后的hash</span></span><br><span class="line">hash ^= table[<span class="number">0</span>][board[<span class="number">0</span>]];</span><br><span class="line">hash ^= table[rand][board[rand]];</span><br><span class="line"><span class="comment">//判断是否可解</span></span><br><span class="line">        <span class="keyword">if</span>(isSolvable(n,board))&#123;</span><br><span class="line">        <span class="comment">//判断是否重复</span></span><br><span class="line"><span class="keyword">if</span> (hs.add(hash))&#123;</span><br><span class="line">i += <span class="number">1</span>;</span><br><span class="line"><span class="comment">//前1000个输出一维数组</span></span><br><span class="line"><span class="keyword">if</span>(i&lt;=<span class="number">1000</span>)&#123;</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">System.out.print(board[j]+<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最后三个输出棋盘及其后继状态</span></span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"State "</span>+(i-<span class="number">1000</span>)+<span class="string">":"</span>);</span><br><span class="line">printb((<span class="keyword">int</span>)Math.sqrt(n),board);</span><br><span class="line">moveShow(board,(<span class="keyword">int</span>)Math.sqrt(n));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出棋盘函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printb</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> b[])</span></span>&#123;</span><br><span class="line"><span class="comment">//遍历数组输出棋子位置</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n*n; j+= n)&#123;</span><br><span class="line"><span class="comment">//格式化输出棋盘“+---+”</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++)</span><br><span class="line">System.out.print(<span class="string">"+---"</span>);</span><br><span class="line">System.out.println(<span class="string">"+"</span>);</span><br><span class="line"><span class="comment">//格式化输出棋子“| * |”</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = j; i &lt; j+n ;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(b[i] &gt; <span class="number">9</span>)</span><br><span class="line">System.out.print(<span class="string">"|"</span>+b[i]+<span class="string">" "</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(b[i] &gt; <span class="number">0</span>)</span><br><span class="line">System.out.print(<span class="string">"| "</span>+b[i]+<span class="string">" "</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">System.out.print(<span class="string">"| "</span>+<span class="string">"#"</span>+<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"|"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//封底</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++)</span><br><span class="line">System.out.print(<span class="string">"+---"</span>);</span><br><span class="line">System.out.println(<span class="string">"+"</span>);</span><br><span class="line">System.out.println(<span class="string">""</span>);</span><br><span class="line">System.out.println(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是否可解</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSolvable</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> b[])</span></span>&#123;</span><br><span class="line"><span class="comment">//棋盘宽度为奇数且逆序对数为偶数</span></span><br><span class="line"><span class="keyword">if</span>(n%<span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(ReversePair(b) %<span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//棋盘宽度为偶数</span></span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//确定白块所在的行号</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(b[i] == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> row = i/(<span class="keyword">int</span>)Math.sqrt(n) + <span class="number">1</span>;</span><br><span class="line"><span class="comment">//在从上起奇数行且逆序对数为奇数</span></span><br><span class="line"><span class="keyword">if</span>(row % <span class="number">2</span> == <span class="number">1</span> &amp;&amp; ReversePair(b) %<span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">//在从上起偶数行且逆序对数为偶数</span></span><br><span class="line"><span class="keyword">if</span>(row % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; ReversePair(b) %<span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] block,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = block[a];</span><br><span class="line">        block[a] = block[b];</span><br><span class="line">        block[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">moveShow</span><span class="params">(<span class="keyword">int</span>[]blcok,<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lofz = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; blcok.length; i ++)&#123;<span class="comment">//寻找空方块即0的位置</span></span><br><span class="line">            <span class="keyword">if</span>(blcok[i] == <span class="number">0</span>)</span><br><span class="line">                lofz  = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(lofz % N != <span class="number">0</span>)&#123;<span class="comment">//判断空方块是否可以和左边交换</span></span><br><span class="line">          swap(blcok,lofz,lofz-<span class="number">1</span>);</span><br><span class="line">          System.out.println(<span class="string">"move left："</span>);</span><br><span class="line">          printb(N,blcok);</span><br><span class="line">          swap(blcok,lofz,lofz-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(lofz % N != N-<span class="number">1</span>)&#123;<span class="comment">//判断空方块是否可以和右边交换</span></span><br><span class="line">            swap(blcok,lofz,lofz+<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">"move right："</span>);</span><br><span class="line">            printb(N,blcok);</span><br><span class="line">            swap(blcok,lofz,lofz+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(lofz + N &lt;= N*N - <span class="number">1</span>) &#123;</span><br><span class="line">            swap(blcok, lofz, lofz + N);</span><br><span class="line">            System.out.println(<span class="string">"move down："</span>);</span><br><span class="line">            printb(N, blcok);</span><br><span class="line">            swap(blcok, lofz, lofz + N);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(lofz - N &gt;= <span class="number">0</span>)  &#123;</span><br><span class="line">            swap(blcok, lofz, lofz - N);</span><br><span class="line">            System.out.println(<span class="string">"move up："</span>);</span><br><span class="line">            printb(N, blcok);</span><br><span class="line">            swap(blcok, lofz, lofz - N);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//数组中的逆序对</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ReversePair</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array==<span class="keyword">null</span>||array.length&lt;=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//复制数组且删掉白块</span></span><br><span class="line">        <span class="keyword">int</span>[] copy = <span class="keyword">new</span> <span class="keyword">int</span>[array.length-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(array[i] != <span class="number">0</span>)</span><br><span class="line">        copy[k++] = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//临时数组</span></span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            temp[i] = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mergeCount(temp, copy, <span class="number">0</span>, array.length-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mergeCount</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span>[] copy, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start==end)&#123;</span><br><span class="line">            copy[start] = array[start];</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//数组一分为二</span></span><br><span class="line">        <span class="keyword">int</span> mid = (start+end)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//递归左侧</span></span><br><span class="line">        <span class="keyword">int</span> leftCount = mergeCount(copy, array, start, mid);</span><br><span class="line">        <span class="comment">//递归右侧</span></span><br><span class="line">        <span class="keyword">int</span> rightCount = mergeCount(copy, array, mid+<span class="number">1</span>, end);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = mid;<span class="comment">//i初始化为前半段最后一个数字的下标</span></span><br><span class="line">        <span class="keyword">int</span> j = end;<span class="comment">//j初始化为后半段最后一个数字的下标</span></span><br><span class="line">        <span class="keyword">int</span> index = end;<span class="comment">//辅助数组复制的数组的最后一个数字的下标</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//计数--逆序对的数目</span></span><br><span class="line">        <span class="comment">//归并排序且比较</span></span><br><span class="line">        <span class="keyword">while</span>(i&gt;=start&amp;&amp;j&gt;=mid+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i]&gt;array[j])&#123;</span><br><span class="line">                copy[index--] = array[i--];</span><br><span class="line">                count += j-mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                copy[index--] = array[j--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(;i&gt;=start;i--)&#123;<span class="comment">//将剩余的放前面</span></span><br><span class="line">            copy[index--] = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(;j&gt;=mid+<span class="number">1</span>;j--)&#123;<span class="comment">//同上</span></span><br><span class="line">            copy[index--] = array[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> leftCount+rightCount+count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆序对的求解</title>
      <link href="/2019/03/17/%E9%80%86%E5%BA%8F%E5%AF%B9%E7%9A%84%E6%B1%82%E8%A7%A3/"/>
      <url>/2019/03/17/%E9%80%86%E5%BA%8F%E5%AF%B9%E7%9A%84%E6%B1%82%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="逆序对的求解问题"><a href="#逆序对的求解问题" class="headerlink" title="逆序对的求解问题"></a>逆序对的求解问题</h3><p>今天在做课程设计作业时，发现需要求解逆序对的问题，对逆序对求解的算法印象比较模糊了，所以复习了一下。</p><h4 id="逆序对问题"><a href="#逆序对问题" class="headerlink" title="逆序对问题"></a>逆序对问题</h4><p>逆序对：在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。</p><p>输入一个数组,求出这个数组中的逆序对的总数：</p><p>如数组{7,5,6,4}，逆序对总共有5对，{7,5}，{7,6}，{7,4}，{5,4}，{6,4}；</p><a id="more"></a><p><strong>思路1：暴力解法，顺序扫描整个数组，每扫描到一个数字的时候，逐个比较该数字和它后面的数字的大小。如果后面的数字比它小，则这两个数字就组成一个逆序对。假设数组中含有n个数字，由于每个数字都要和O(n)个数字作比较，因此这个算法的时间复杂度是O(n2)。</strong></p><p><strong>思路2：分治思想，采用归并排序的思路来处理，如下图，先分后治：</strong></p><p><img src="/2019/03/17/逆序对的求解/分治.png" alt="分治思想"></p><p>先把数组分解成两个长度为2的子数组，再把这两个子数组分解成两个长度为1的子数组。接下来一边合并相邻的子数组，一边统计逆序对的数目。在第一对长度为1的子数组{7}、{5}中7&gt;5，因此（7,5）组成一个逆序对。同样在第二对长度为1的子数组{6}，{4}中也有逆序对（6,4），由于已经统计了这两对子数组内部的逆序对，因此需要把这两对子数组进行排序，避免在之后的统计过程中重复统计。</p><p><strong>逆序对的总数=左边数组中的逆序对的数量+右边数组中逆序对的数量+左右结合成新的顺序数组时中出现的逆序对的数量；</strong></p><p>总结统计数组逆序对的过程：先把数组分隔成子数组，先统计出子数组内部的逆序对的数目，然后再统计出两个相邻子数组之间的逆序对的数目。在统计逆序对的过程中，还需要对数组进行排序，其实这个排序过程就是归并排序的思路。</p><p>Java实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组中的逆序对</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ReversePair</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array==<span class="keyword">null</span>||array.length&lt;=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] copy = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            copy[i] = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mergeCount(array, copy, <span class="number">0</span>, array.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mergeCount</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span>[] copy, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start==end)&#123;</span><br><span class="line">            copy[start] = array[start];</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (start+end)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> leftCount = mergeCount(copy, array, start, mid);</span><br><span class="line">        <span class="keyword">int</span> rightCount = mergeCount(copy, array, mid+<span class="number">1</span>, end);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = mid;<span class="comment">//i初始化为前半段最后一个数字的下标</span></span><br><span class="line">        <span class="keyword">int</span> j = end;<span class="comment">//j初始化为后半段最后一个数字的下标</span></span><br><span class="line">        <span class="keyword">int</span> index = end;<span class="comment">//辅助数组复制的数组的最后一个数字的下标</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//计数--逆序对的数目</span></span><br><span class="line">        <span class="keyword">while</span>(i&gt;=start&amp;&amp;j&gt;=mid+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i]&gt;array[j])&#123;</span><br><span class="line">                copy[index--] = array[i--];</span><br><span class="line">                count += j-mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                copy[index--] = array[j--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(;i&gt;=start;i--)&#123;<span class="comment">//将剩余的放前面</span></span><br><span class="line">            copy[index--] = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(;j&gt;=mid+<span class="number">1</span>;j--)&#123;<span class="comment">//同上</span></span><br><span class="line">            copy[index--] = array[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> leftCount+rightCount+count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Python 2实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reversePair</span><span class="params">(array)</span>:</span></span><br><span class="line"><span class="keyword">if</span> array:</span><br><span class="line">temp = array[:]</span><br><span class="line">end = len(array)<span class="number">-1</span></span><br><span class="line"><span class="keyword">return</span> mergeCount(array,temp,<span class="number">0</span>,end)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeCount</span><span class="params">(array,temp,start,end)</span>:</span></span><br><span class="line"><span class="keyword">if</span> start <span class="keyword">is</span> end:</span><br><span class="line">temp[start] = array[start]</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">mid = (start + end)/<span class="number">2</span></span><br><span class="line">leftCount = mergeCount(array,temp,start,mid)</span><br><span class="line">rightCount = mergeCount(array,temp,mid+<span class="number">1</span>,end)</span><br><span class="line"></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">i = mid</span><br><span class="line">j = end</span><br><span class="line">k = end</span><br><span class="line">copy = temp[:]</span><br><span class="line"><span class="keyword">while</span> i &gt;= start <span class="keyword">and</span> j &gt;= mid+<span class="number">1</span>:</span><br><span class="line"><span class="keyword">if</span> temp[i] &gt; temp[j]:</span><br><span class="line">copy[k] = temp[i]</span><br><span class="line">count += j - mid</span><br><span class="line">i -= <span class="number">1</span></span><br><span class="line">k -= <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">copy[k] = temp[j]</span><br><span class="line">j -= <span class="number">1</span></span><br><span class="line">k -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> i &gt;= start:</span><br><span class="line">copy[k] = temp[i]</span><br><span class="line">i -= <span class="number">1</span></span><br><span class="line">k -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> j &gt;= mid+<span class="number">1</span>:</span><br><span class="line">copy[k] = temp[j]</span><br><span class="line">j -= <span class="number">1</span></span><br><span class="line">k -= <span class="number">1</span></span><br><span class="line">temp[start:end+<span class="number">1</span>] = copy[start:end+<span class="number">1</span>]</span><br><span class="line"><span class="keyword">return</span> leftCount+rightCount+count</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">array = [<span class="number">7</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">print</span> reversePair(array)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Java </tag>
            
            <tag> 逆序对 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/03/16/hello-world/"/>
      <url>/2019/03/16/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
