<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LeetCode-2-两数相加</title>
      <link href="/2019/08/02/LeetCode-2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
      <url>/2019/08/02/LeetCode-2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
      
        <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给出两个<strong>非空</strong>的链表用来表示两个非负的整数。其中，它们各自的位数是按照<strong>逆序</strong>的方式存储的，并且它们的每个节点只能存储<strong>一位</strong>数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><blockquote><p>示例：</p><p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p></blockquote><p><a href="https://leetcode-cn.com/problems/add-two-numbers" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><h5 id="初步解法"><a href="#初步解法" class="headerlink" title="初步解法"></a>初步解法</h5><p>刚一看到题目就想到了第一种思路：首先根据两个链表读出其中的数据，对两个数据求和，然后通过模和除求出和的每一位数字，建立新链表。</p><p>代码很快就写好了，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">addTwoNumbers</span><span class="params">(struct ListNode* l1, struct ListNode* l2)</span></span>&#123;</span><br><span class="line">    <span class="comment">//求和</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">l</span> = <span class="title">l1</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sum = <span class="number">0</span>,val;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(count&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> order = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            sum += (<span class="keyword">int</span>)((l-&gt;val)*<span class="built_in">pow</span>(<span class="number">10.0</span>,(<span class="keyword">double</span>)order));</span><br><span class="line">            l = l-&gt;next;</span><br><span class="line">            order += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">        l = l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分解所得和并建立新链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">result</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">newNode1</span> = (<span class="title">struct</span> <span class="title">ListNode</span> *) <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    newNode1-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    result = newNode1;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        val = sum % <span class="number">10</span>;</span><br><span class="line">        sum = sum / <span class="number">10</span>;</span><br><span class="line">        newNode1-&gt;val = val;</span><br><span class="line">        <span class="keyword">if</span>(sum != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">newNode2</span> = (<span class="title">struct</span> <span class="title">ListNode</span> *) <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">            newNode2-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            newNode1-&gt;next = newNode2;</span><br><span class="line">            newNode1 = newNode2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="初步解法遇到的问题"><a href="#初步解法遇到的问题" class="headerlink" title="初步解法遇到的问题"></a>初步解法遇到的问题</h5><p>代码运行成功解出样例，但是提交发现，测试所给数据位数很多，数据很大，求和后会溢出，即使改用<code>long</code>类型依然无法补救，故初步解法扑街。</p><h5 id="进阶解法"><a href="#进阶解法" class="headerlink" title="进阶解法"></a>进阶解法</h5><p>既然初步解法没用，只能换一种思路。想到以前学过的链表合并算法，可以借鉴一波。</p><p>新思路：因为两个链表从头结点开始，每个对应的结点都是相同位上的数字（个十百千），所以从头结点开始，两个结点相加，求出该位数字，并记录进位，相应的，也要记录前一位给当前位的进位。当某一链表结束之后，剩下的位取没结束的那个链表（此处别忘记前一位的进位）。</p><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">addTwoNumbers</span><span class="params">(struct ListNode* l1, struct ListNode* l2)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">n1</span> = <span class="title">l1</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">n2</span> = <span class="title">l2</span>;</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;<span class="comment">//本位和</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//给下一位的进位</span></span><br><span class="line">    <span class="keyword">int</span> precount = <span class="number">0</span>;<span class="comment">//前一位的进位</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">result</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">newNode1</span> = (<span class="title">struct</span> <span class="title">ListNode</span> *) <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    newNode1-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    result = newNode1;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        precount = count;<span class="comment">//更新前一位的进位</span></span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//两链表都不空时</span></span><br><span class="line">        <span class="keyword">if</span>(n1 != <span class="literal">NULL</span> &amp;&amp; n2 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            sum = n1-&gt;val + n2-&gt;val + precount;</span><br><span class="line">            <span class="keyword">if</span>(sum &gt; <span class="number">9</span>)&#123;</span><br><span class="line">                sum -= <span class="number">10</span>;</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            n1 = n1-&gt;next;</span><br><span class="line">            n2 = n2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//单一链表为空时</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n1 == <span class="literal">NULL</span> &amp;&amp; n2 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            sum = n2-&gt;val + precount;</span><br><span class="line">            <span class="keyword">if</span>(sum &gt; <span class="number">9</span>)&#123;</span><br><span class="line">                sum -= <span class="number">10</span>;</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            n2 = n2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n2 == <span class="literal">NULL</span> &amp;&amp; n1 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            sum = n1-&gt;val + precount;</span><br><span class="line">            <span class="keyword">if</span>(sum &gt; <span class="number">9</span>)&#123;</span><br><span class="line">                sum -= <span class="number">10</span>;</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            n1 = n1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        newNode1-&gt;val = sum;</span><br><span class="line">        <span class="comment">//两链表同为空</span></span><br><span class="line">        <span class="keyword">if</span>(n1 == <span class="literal">NULL</span> &amp;&amp; n2 == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="comment">//此时不能忘记前面的进位</span></span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">newNode2</span> = (<span class="title">struct</span> <span class="title">ListNode</span> *) <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">                newNode2-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">                newNode1-&gt;next = newNode2;</span><br><span class="line">                newNode1 = newNode2;</span><br><span class="line">                newNode1-&gt;val = count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">newNode2</span> = (<span class="title">struct</span> <span class="title">ListNode</span> *) <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">        newNode2-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        newNode1-&gt;next = newNode2;</span><br><span class="line">        newNode1 = newNode2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该代码提交成功，并击败约98%的人。</p><h5 id="进阶解法踩到的坑"><a href="#进阶解法踩到的坑" class="headerlink" title="进阶解法踩到的坑"></a>进阶解法踩到的坑</h5><ul><li>两链表都结束后，要考虑到最后的进位，可能后面还有一位数，例如：9 + 991 = 1000</li><li>检测到两链表同时结束后，此时应该看的进位变量应为<code>count</code>，而不是<code>precount</code>，因为还没到下一节点</li><li>不要忘记让节点指向<code>next</code>，否则会死循环</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>该题目未给出数据取值范围，所以会出现第一种解法。</li><li>这道题目考察链表的有关内容（参见数据结构），涉及到链表的合并、建立等。</li><li>做这道题目莫名地想到了“大数相乘”的求解，以后有机会补充一下。</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-1-两数之和</title>
      <link href="/2019/08/01/LeetCode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/2019/08/01/LeetCode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的那<strong>两个</strong>整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><p>示例:</p><blockquote><p>给定 nums = [2, 7, 11, 15], target = 9</p><p>因为 nums[0] + nums[1] = 2 + 7 = 9</p><p>所以返回 [0, 1]</p></blockquote><p><a href="https://leetcode-cn.com/problems/two-sum" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><h5 id="初步解法"><a href="#初步解法" class="headerlink" title="初步解法"></a>初步解法</h5><p>刚看到题目，第一反应是暴力求解，即类似于选择排序的算法，从头开始利用每个值与其后的值逐个判断。这种方法思路简单，但时间复杂度高，为 $ O(n^2)$ </p><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">twoSum</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target, <span class="keyword">int</span>* returnSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">int</span>* two_nums = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;numsSize<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;numsSize;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]+nums[j] == target)&#123;</span><br><span class="line">                two_nums[<span class="number">0</span>] = i;</span><br><span class="line">                two_nums[<span class="number">1</span>] = j;</span><br><span class="line">                *returnSize = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">return</span> two_nums;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="踩到的坑"><a href="#踩到的坑" class="headerlink" title="踩到的坑"></a>踩到的坑</h5><p>最开始以为<code>returnSize</code>是结果数组，所以用<code>malloc()</code>为它申请了内存空间，然后运行一直报错。然后根据字面意思和提交结果，猜测这个参数是一地址传递的参数，在主函数内控制输出个数。（因为之前输出结果一直为空）所以在找到结果时将其改写为2，另外申请一块内存存储结果。</p><h5 id="解法进阶"><a href="#解法进阶" class="headerlink" title="解法进阶"></a>解法进阶</h5><p>思路：用Hash表的形式存储数据，用空间复杂度换时间复杂度。</p><p>引用LeetCode上的一个解的代码：</p><p><a href="https://leetcode-cn.com/problems/two-sum/solution/cyu-yan-yi-bian-ha-xi-kong-jian-onhuan-shi-jian-on/" target="_blank" rel="noopener">代码链接</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hash_node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;            <span class="comment">/* we'll use this field as the key */</span></span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    UT_hash_handle hh; <span class="comment">/* makes this structure hashable */</span></span><br><span class="line">&#125; hash_node;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">twoSum</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target, <span class="keyword">int</span>* returnSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *two_nums = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">2</span>);</span><br><span class="line">    hash_node *hash_table = <span class="literal">NULL</span>, *hash_item1 = <span class="literal">NULL</span>, *hash_item2 = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        <span class="comment">// 查找哈希表中是否存在满足和为target的另一个值,若存在直接返回</span></span><br><span class="line">        <span class="keyword">int</span> other_id = target - *(nums+i);</span><br><span class="line">        HASH_FIND_INT(hash_table, &amp;other_id, hash_item1);</span><br><span class="line">        <span class="keyword">if</span> (hash_item1) &#123;</span><br><span class="line">            two_nums[<span class="number">0</span>] = hash_item1-&gt;index;</span><br><span class="line">            two_nums[<span class="number">1</span>] = i;</span><br><span class="line">            *returnSize = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> two_nums;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将本次遍历的值放入哈希表,value为数组下标,key为对应数值</span></span><br><span class="line">        hash_item2 = (hash_node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(hash_node));</span><br><span class="line">        hash_item2-&gt;id = *(nums+i);</span><br><span class="line">        hash_item2-&gt;index = i;</span><br><span class="line">        HASH_ADD_INT(hash_table, id, hash_item2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> two_nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>HASH_FIND_INT()、HASH_ADD_INT()</code>等函数是来自C语言的一个开源库 <a href="https://troydhanson.github.io/uthash/" target="_blank" rel="noopener"><code>uthash</code></a></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>这道题考察的内容不多，包括一些C语言中的指针的使用，<code>malloc()</code>函数的使用等。</li><li>使用哈希表来存储并重复查找数据，可以大幅降低时间复杂度，但会增大空间复杂度。</li><li>这是我第一次在C语言中使用哈希表，还需要使用外部库。如果是在Python中，可以利用字典这一数据结构，使用起来更方便。</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录几个Linux下文件比较工具</title>
      <link href="/2019/05/17/%E8%AE%B0%E5%BD%95%E5%87%A0%E4%B8%AALinux%E4%B8%8B%E6%96%87%E4%BB%B6%E6%AF%94%E8%BE%83%E5%B7%A5%E5%85%B7/"/>
      <url>/2019/05/17/%E8%AE%B0%E5%BD%95%E5%87%A0%E4%B8%AALinux%E4%B8%8B%E6%96%87%E4%BB%B6%E6%AF%94%E8%BE%83%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<p>简略记录Linux下用来比较文件异同的命令工具。</p><a id="more"></a><p>cmp 比较两个文件，并指出它们是否不同及不同的字节。</p><p>diff 比较两个文件或目录，并指出哪些文件的哪些行不同。</p><p>diff3 逐行比较三个文件。</p><p>sdiff 合并两个文件，并以交互方式输出结果。</p><p>vimdiff 使用vim同时编辑一个文档的2或3个版本并显示他们的区别使用。</p><p>comm 一行一行对两个已经排序的文件进行比较，在第三列中显示同一行是否相同。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中文分词实验及FMM与BMM算法实现</title>
      <link href="/2019/05/03/%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E5%AE%9E%E9%AA%8C%E5%8F%8AFMM%E4%B8%8EBMM%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/05/03/%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E5%AE%9E%E9%AA%8C%E5%8F%8AFMM%E4%B8%8EBMM%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>此为在课上做的一个实验，涉及内容较多故做如下记录。</p><p>主要分为三部分：实现中文分词、实现FMM算法、实现BMM算法</p><a id="more"></a><h4 id="中文分词"><a href="#中文分词" class="headerlink" title="中文分词"></a>中文分词</h4><h5 id="基本要求"><a href="#基本要求" class="headerlink" title="基本要求"></a>基本要求</h5><p>给定语料库，从中识别中文分词并统计词频。</p><p>语料库示例：</p><p>19980101-01-001-001/m  迈向/v  充满/v  希望/n  的/u  新/a  世纪/n  ——/w  一九九八年/t  新年/t  讲话/n  （/w  附/v  图片/n  １/m  张/q  ）/w  </p><p>19980101-01-001-006/m  在/p  １９９８年/t  来临/v  之际/f  ，/w  我/r  十分/m  高兴/a  地/u  通过/p  [中央/n  人民/n  广播/vn  电台/n]nt  、/w  [中国/ns  国际/n  广播/vn  电台/n]nt  和/c  [中央/n  电视台/n]nt  ，/w  向/p  全国/n  各族/r  人民/n  ，/w  向/p  [香港/ns  特别/a  行政区/n]ns  同胞/n  、/w  澳门/ns  和/c  台湾/ns  同胞/n  、/w  海外/s  侨胞/n  ，/w  向/p  世界/n  各国/r  的/u  朋友/n  们/k  ，/w  致以/v  诚挚/a  的/u  问候/vn  和/c  良好/a  的/u  祝愿/vn  ！/w  </p><p>结果示例：</p><p>民心所向:1<br>实劲:1<br>音乐声:1</p><p>……</p><p>。:35983<br>的:54487<br>，:74921</p><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addtodic</span><span class="params">(dic,s)</span>:</span></span><br><span class="line"><span class="keyword">if</span> dic. __contains__(s):</span><br><span class="line">dic[s] += <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">dic[s] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(dic,data)</span>:</span></span><br><span class="line">    <span class="comment">#识别普通分词</span></span><br><span class="line">pattern1 = <span class="string">u'[\u0080-\uFFFD0-9\-]+'</span></span><br><span class="line">p = re.compile(pattern1)</span><br><span class="line">l = p.findall(data)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> l:</span><br><span class="line">        <span class="comment">#去掉时间</span></span><br><span class="line"><span class="keyword">if</span> re.match(<span class="string">r"[0-9]+-[0-9]+-"</span>,i):</span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">addtodic(dic,i)</span><br><span class="line"></span><br><span class="line"><span class="comment">#识别形如[.*]的分词</span></span><br><span class="line">l = []</span><br><span class="line">temp = []</span><br><span class="line">pattern2 = <span class="string">u'\[[\u0080-\uFFFD\u0020/0-9\w]+\]?'</span></span><br><span class="line">p = re.compile(pattern2)</span><br><span class="line">l = p.findall(data)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> l:</span><br><span class="line">temp = re.compile(pattern1).findall(i)</span><br><span class="line">s = <span class="string">""</span>.join(i <span class="keyword">for</span> i <span class="keyword">in</span> temp)</span><br><span class="line">addtodic(dic,s)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">file = open(<span class="string">"./ylk.txt"</span>,<span class="string">'r'</span>,encoding = <span class="string">"utf-8"</span>)</span><br><span class="line">data = file.read()</span><br><span class="line">data = data[<span class="number">3</span>:]</span><br><span class="line">dic = &#123;&#125;</span><br><span class="line">create(dic,data)</span><br><span class="line">l = sorted(dic.items(),key = <span class="keyword">lambda</span> item:item[<span class="number">1</span>])</span><br><span class="line">outfile = open(<span class="string">'./dic.txt'</span>,<span class="string">'w'</span>)</span><br><span class="line">print(len(l))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> l:</span><br><span class="line">s = <span class="string">""</span>+i[<span class="number">0</span>]+<span class="string">":"</span>+str(i[<span class="number">1</span>])+<span class="string">"\n"</span></span><br><span class="line">outfile.write(s)</span><br><span class="line">print(s)</span><br><span class="line"><span class="comment">#break</span></span><br><span class="line">outfile.close()</span><br></pre></td></tr></table></figure><h5 id="补充：Unicode中文编码范围："><a href="#补充：Unicode中文编码范围：" class="headerlink" title="补充：Unicode中文编码范围："></a>补充：Unicode中文编码范围：</h5><p>2E80～33FFh：中日韩符号区。收容康熙字典部首、中日韩辅助部首、注音符号、日本假名、韩文音符，中日韩的符号、标点、带圈或带括符文数字、月份，以及日本的假名组合、单位、年号、月份、日期、时间等。<br>3400～4DFFh：中日韩认同表意文字扩充A区，总计收容6,582个中日韩汉字。<br>4E00～9FFFh：中日韩认同表意文字区，总计收容20,902个中日韩汉字。<br>A000～A4FFh：彝族文字区，收容中国南方彝族文字和字根。<br>AC00～D7FFh：韩文拼音组合字区，收容以韩文音符拼成的文字。<br>F900～FAFFh：中日韩兼容表意文字区，总计收容302个中日韩汉字。<br>FB00～FFFDh：文字表现形式区，收容组合拉丁文字、希伯来文、阿拉伯文、中日韩直式标点、小符号、半角符号、全角符号等。</p><h4 id="FMM算法实现"><a href="#FMM算法实现" class="headerlink" title="FMM算法实现"></a>FMM算法实现</h4><h5 id="FMM简介"><a href="#FMM简介" class="headerlink" title="FMM简介"></a>FMM简介</h5><p>FMM即正向最大匹配分词，即每次向后读取maxWordLength个字，如若匹配则继续，否则回退一个字继续匹配，直至单字无法匹配，将其单独分词。经统计，示例单词本中的maxWordLength为32。</p><h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fmm</span><span class="params">(sentence,dic)</span>:</span></span><br><span class="line">    sentence = sentence.strip(<span class="string">"\n"</span>)</span><br><span class="line">    result = <span class="string">""</span></span><br><span class="line">    succ = <span class="number">0</span></span><br><span class="line">    maxlength = <span class="number">32</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> len(sentence) <span class="keyword">is</span> <span class="number">0</span>:</span><br><span class="line">        temp_s = sentence[:maxlength]</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> dic.__contains__(temp_s):</span><br><span class="line">            <span class="keyword">if</span> len(temp_s) &gt; <span class="number">1</span>:</span><br><span class="line">                temp_s = temp_s[:<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        result += temp_s+<span class="string">'/'</span></span><br><span class="line">        sentence = sentence[len(temp_s):]</span><br></pre></td></tr></table></figure><h5 id="分词结果"><a href="#分词结果" class="headerlink" title="分词结果"></a>分词结果</h5><p>祝愿/祖国/明天/更加/繁荣昌盛/香港/大学生/在/京/度/佳节/新华社/北京/１月/１日/电/昨晚/，/第一/次/来到/首都/北京/的/５０/多/名/香港/大学生/，/和/北京航空航天大学/的/同学/们/在/《/歌唱/祖国/》/的/歌声/中/一起/迎接/１９９８年/的/到来/。/此次/到/京/的/香港/大学生/来自/香港科技大学/和/浸会大学/，/他们/于/１２月/３０日/抵京/后/参观/了/北大/、/清华/和/抗日战争纪念馆/。/在/中国青年政治学院/，/两地/大学生/就学/习/、/生活/等/共同/关心/的话/题/展开/了/交流/。/</p><h4 id="BMM算法实现"><a href="#BMM算法实现" class="headerlink" title="BMM算法实现"></a>BMM算法实现</h4><h5 id="BMM简介"><a href="#BMM简介" class="headerlink" title="BMM简介"></a>BMM简介</h5><p>BMM即反向最大匹配分词，每次从句尾向前读取maxWordLength个字，如若匹配则继续，否则去掉最左侧单字继续匹配，直至单字无法匹配，将其单独分词。</p><h5 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bmm</span><span class="params">(sentence,dic)</span>:</span></span><br><span class="line">    sentence = sentence.strip(<span class="string">"\n"</span>)</span><br><span class="line">    result = []</span><br><span class="line">    succ = <span class="number">0</span></span><br><span class="line">    maxlength = <span class="number">32</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> len(sentence) <span class="keyword">is</span> <span class="number">0</span>:</span><br><span class="line">        temp_s = sentence[len(sentence)-maxlength:]</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> dic.__contains__(temp_s):</span><br><span class="line">            <span class="keyword">if</span> len(temp_s) &gt; <span class="number">1</span>:</span><br><span class="line">                temp_s = temp_s[<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        result.append(temp_s)</span><br><span class="line">        sentence = sentence[:len(sentence)-len(temp_s)]</span><br><span class="line">    res = <span class="string">""</span>.join(s+<span class="string">'/'</span> <span class="keyword">for</span> s <span class="keyword">in</span> reversed(result))</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h5 id="分词结果-1"><a href="#分词结果-1" class="headerlink" title="分词结果"></a>分词结果</h5><p>祝愿/祖国/明天/更加/繁荣昌盛/香港/大学生/在/京/度/佳节/新华社/北京/１月/１日/电/昨晚/，/第一/次/来到/首都/北京/的/５０/多/名/香港/大学生/，/和/北京航空航天大学/的/同学/们/在/《/歌唱/祖国/》/的/歌声/中/一起/迎接/１９９８年/的/到来/。/此次/到/京/的/香港/大学生/来自/香港科技大学/和/浸会大学/，/他们/于/１/２月/３０日/抵京/后/参观/了/北大/、/清华/和/抗日战争纪念馆/。/在/中国青年政治学院/，/两地/大学生/就/学习/、/生活/等/共同/关心/的/话题/展开/了/交流/。/</p><h4 id="两种算法的分词结果比较"><a href="#两种算法的分词结果比较" class="headerlink" title="两种算法的分词结果比较"></a>两种算法的分词结果比较</h4><p>FMM与BMM分词结果不完全相同，比如例句：</p><p>​    对于两地大学生就学习、生活等共同关心的话题展开了交流。</p><p>FMM分词结果为：</p><p>​    /两地/大学生/就学/习/、/生活/等/共同/关心/的话/题/展开/了/交流/。/</p><p>BMM分词结果为：</p><p>​    /两地/大学生/就/学习/、/生活/等/共同/关心/的/话题/展开/了/交流/。/</p><p>从语义来说，BMM分词更为准确。</p>]]></content>
      
      
      <categories>
          
          <category> 数字内容安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unicode </tag>
            
            <tag> 中文字符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>位图文件的读取与显示</title>
      <link href="/2019/03/24/%E4%BD%8D%E5%9B%BE%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%8F%96%E4%B8%8E%E6%98%BE%E7%A4%BA/"/>
      <url>/2019/03/24/%E4%BD%8D%E5%9B%BE%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%8F%96%E4%B8%8E%E6%98%BE%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<h4 id="要求："><a href="#要求：" class="headerlink" title="要求："></a>要求：</h4><p>通过代码实现位图的显示与修改。</p><p>位图显示：首先，通过代码实现文件的读取，按照前面给定的格式解析文件内容，将解析出的颜色显示在对应的坐标当中。</p><p>位图修改：将像素点中所有的黑色像素修改成（0,0,255），并进行显示和保存。</p><p>编程语言不限，但是不可以使用任何针对图像处理的库函数（OpenCV、PIL等），必须直接读取二进制文件，按照给定的格式进行解析。</p><a id="more"></a><h4 id="位图文件格式说明"><a href="#位图文件格式说明" class="headerlink" title="位图文件格式说明"></a>位图文件格式说明</h4><p>位图文件格式由四部分组成，如图 1所示，分别是<strong>位图文件头</strong>、<strong>位图信息头</strong>、<strong>调色板</strong>以及<strong>位图像素数据</strong>，其中调色板信息为可选信息，只有当每个像素的比特数小于或等于8（BITMAPINFOHEADER.biBitCount&lt;=8）时才存在，即为一个颜色查找表。</p><p>需要注意的是，位图文件存储时为了提高内存访问的速度，每一行的字节数必须是4的倍数，即：如果一幅图像的宽度为253，每个像素用8bit表示，因此，该图像实际每行所占的存储空间数为253Byte，但为了与4对齐，存储时所用的存储空间为256Byte。具体而言，假设图像的宽度为w，每个像素用n比特表示，则图像每行像素所占的字节数为：</p><p>​            (w <em> n + 31)/32 </em> 4</p><p><img src="/2019/03/24/位图文件的读取与显示/结构.png" alt="结构"></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义三个文件头</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tagBITMAPFILEHEADER</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_init_</span><span class="params">(self)</span>:</span></span><br><span class="line">self.bfType = <span class="number">0</span></span><br><span class="line">self.bfsize = <span class="number">0</span></span><br><span class="line">self.bfReserved1 = <span class="number">0</span></span><br><span class="line">self.bfReserved2 = <span class="number">0</span></span><br><span class="line">self.bfOffBits = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tagBITMAPINFOHEADER</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_init_</span><span class="params">(self)</span>:</span></span><br><span class="line">self.biSize = <span class="number">0</span></span><br><span class="line">self.biWidth = <span class="number">0</span></span><br><span class="line">self.biHeight = <span class="number">0</span></span><br><span class="line">self.biPlanes = <span class="number">1</span></span><br><span class="line">self.biBitCount = <span class="number">0</span></span><br><span class="line">self.biCompression = <span class="number">0</span></span><br><span class="line">self.biSizeImage = <span class="number">0</span></span><br><span class="line">self.biXPelsPerMeter = <span class="number">0</span></span><br><span class="line">self.biYPelsPerMeter = <span class="number">0</span></span><br><span class="line">self.BiClrUsed = <span class="number">0</span></span><br><span class="line">self.bClrImportant = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tagRGBQUAD</span><span class="params">()</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_init_</span><span class="params">(self)</span>:</span></span><br><span class="line">self.rgbBlue = <span class="number">0</span></span><br><span class="line">self.rgbGreen = <span class="number">0</span></span><br><span class="line">self.rgbRed = <span class="number">0</span></span><br><span class="line">self.rbgReserved = <span class="number">0</span></span><br><span class="line"><span class="comment">#定义RGB结构体</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">rgb</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_init_</span><span class="params">(self)</span>:</span></span><br><span class="line">self.R = <span class="number">0</span></span><br><span class="line">self.G = <span class="number">0</span></span><br><span class="line">self.B = <span class="number">0</span></span><br><span class="line"><span class="comment">#读取bmp图片</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_bmp</span><span class="params">(file,BITMAPFILEHEADER,BITMAPINFOHEADER,imageData)</span>:</span></span><br><span class="line"><span class="comment">#读文件头</span></span><br><span class="line">fileHeader = file.read(<span class="number">14</span>)</span><br><span class="line">BITMAPFILEHEADER.bfType = struct.unpack(<span class="string">"&lt;H"</span>, fileHeader[:<span class="number">2</span>])[<span class="number">0</span>]</span><br><span class="line">BITMAPFILEHEADER.bfsize = struct.unpack(<span class="string">"&lt;I"</span>, fileHeader[<span class="number">2</span>:<span class="number">6</span>])[<span class="number">0</span>]</span><br><span class="line">BITMAPFILEHEADER.bfReserved1 = struct.unpack(<span class="string">"&lt;H"</span>, fileHeader[<span class="number">6</span>:<span class="number">8</span>])[<span class="number">0</span>]</span><br><span class="line">BITMAPFILEHEADER.bfReserved2 = struct.unpack(<span class="string">"&lt;H"</span>, fileHeader[<span class="number">8</span>:<span class="number">10</span>])[<span class="number">0</span>]</span><br><span class="line">BITMAPFILEHEADER.bfOffBits = struct.unpack(<span class="string">"&lt;I"</span>, fileHeader[<span class="number">10</span>:<span class="number">14</span>])[<span class="number">0</span>]</span><br><span class="line"><span class="comment">#读信息头</span></span><br><span class="line">infoHeader = file.read(<span class="number">40</span>)</span><br><span class="line">BITMAPINFOHEADER.biSize = struct.unpack(<span class="string">"&lt;I"</span>, infoHeader[:<span class="number">4</span>])[<span class="number">0</span>]</span><br><span class="line">BITMAPINFOHEADER.biWidth = struct.unpack(<span class="string">"&lt;L"</span>, infoHeader[<span class="number">4</span>:<span class="number">8</span>])[<span class="number">0</span>]</span><br><span class="line">BITMAPINFOHEADER.biHeight = struct.unpack(<span class="string">"&lt;L"</span>, infoHeader[<span class="number">8</span>:<span class="number">12</span>])[<span class="number">0</span>]</span><br><span class="line">BITMAPINFOHEADER.biPlanes = struct.unpack(<span class="string">"&lt;H"</span>, infoHeader[<span class="number">12</span>:<span class="number">14</span>])[<span class="number">0</span>]</span><br><span class="line">BITMAPINFOHEADER.biBitCount = struct.unpack(<span class="string">"&lt;H"</span>, infoHeader[<span class="number">14</span>:<span class="number">16</span>])[<span class="number">0</span>]</span><br><span class="line">BITMAPINFOHEADER.biCompression = struct.unpack(<span class="string">"&lt;I"</span>, infoHeader[<span class="number">16</span>:<span class="number">20</span>])[<span class="number">0</span>]</span><br><span class="line">BITMAPINFOHEADER.biSizeImage = struct.unpack(<span class="string">"&lt;I"</span>, infoHeader[<span class="number">20</span>:<span class="number">24</span>])[<span class="number">0</span>]</span><br><span class="line">BITMAPINFOHEADER.biXPelsPerMeter = struct.unpack(<span class="string">"&lt;L"</span>, infoHeader[<span class="number">24</span>:<span class="number">28</span>])[<span class="number">0</span>]</span><br><span class="line">BITMAPINFOHEADER.biYPelsPerMeter = struct.unpack(<span class="string">"&lt;L"</span>, infoHeader[<span class="number">28</span>:<span class="number">32</span>])[<span class="number">0</span>]</span><br><span class="line">BITMAPINFOHEADER.BiClrUsed = struct.unpack(<span class="string">"&lt;I"</span>, infoHeader[<span class="number">32</span>:<span class="number">36</span>])[<span class="number">0</span>]</span><br><span class="line">BITMAPINFOHEADER.bClrImportant = struct.unpack(<span class="string">"&lt;I"</span>, infoHeader[<span class="number">36</span>:<span class="number">40</span>])[<span class="number">0</span>]</span><br><span class="line"><span class="comment">#读像素点</span></span><br><span class="line"><span class="comment">#if BITMAPINFOHEADER.biBitCount is 24:</span></span><br><span class="line">num = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,BITMAPINFOHEADER.biHeight*BITMAPINFOHEADER.biWidth):</span><br><span class="line">s = file.read(<span class="number">3</span>)</span><br><span class="line">num += <span class="number">1</span></span><br><span class="line">RGB = rgb()</span><br><span class="line">RGB.R = struct.unpack(<span class="string">"&lt;B"</span>, s[<span class="number">0</span>])[<span class="number">0</span>]</span><br><span class="line">RGB.G = struct.unpack(<span class="string">"&lt;B"</span>, s[<span class="number">1</span>])[<span class="number">0</span>]</span><br><span class="line">RGB.B = struct.unpack(<span class="string">"&lt;B"</span>, s[<span class="number">2</span>])[<span class="number">0</span>]</span><br><span class="line"><span class="comment">#print RGB.R,RGB.G,RGB.B</span></span><br><span class="line">imageData.append(RGB)</span><br><span class="line"><span class="keyword">if</span> num % BITMAPINFOHEADER.biWidth <span class="keyword">is</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">if</span> (num*<span class="number">3</span>)%<span class="number">4</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="number">0</span>:</span><br><span class="line">s = file.read( <span class="number">4</span> - ((num*<span class="number">3</span>)%<span class="number">4</span> ))</span><br><span class="line">num = <span class="number">0</span></span><br><span class="line"><span class="comment">#修改像素点</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bmp_modify</span><span class="params">(imageData)</span>:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> imageData:</span><br><span class="line"><span class="keyword">if</span> i.R &lt; <span class="number">40</span> <span class="keyword">and</span> i.G &lt; <span class="number">40</span> <span class="keyword">and</span> i.B &lt; <span class="number">40</span>:</span><br><span class="line">i.R = <span class="number">0</span></span><br><span class="line">i.G = <span class="number">0</span></span><br><span class="line">i.B = <span class="number">255</span></span><br><span class="line"><span class="comment">#将像素点写入文件</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">writeFile</span><span class="params">(imageData,file,width)</span>:</span></span><br><span class="line">num = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> imageData:</span><br><span class="line">b = struct.pack(<span class="string">"&lt;BBB"</span>,i.R,i.G,i.B)</span><br><span class="line">file.write(b)</span><br><span class="line">num += <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> num % width <span class="keyword">is</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">if</span> (num*<span class="number">3</span>)%<span class="number">4</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="number">0</span>:</span><br><span class="line">file.write((<span class="number">4</span>- (num*<span class="number">3</span>)%<span class="number">4</span> ) * <span class="string">'a'</span>)</span><br><span class="line">num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"><span class="comment">#存取文件头及像素点</span></span><br><span class="line">BITMAPFILEHEADER = tagBITMAPFILEHEADER()</span><br><span class="line">BITMAPINFOHEADER = tagBITMAPINFOHEADER()</span><br><span class="line">imageData = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">r'./logo.bmp'</span>,<span class="string">'rb'</span>) <span class="keyword">as</span> file:</span><br><span class="line">read_bmp(file,BITMAPFILEHEADER,BITMAPINFOHEADER,imageData)</span><br><span class="line"></span><br><span class="line"><span class="comment">#读出宽度，写入时使用</span></span><br><span class="line">width = BITMAPINFOHEADER.biWidth</span><br><span class="line"><span class="comment">#查找符合条件的点</span></span><br><span class="line">bmp_modify(imageData)</span><br><span class="line"><span class="comment">#写入新文件</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">r'./logo.bmp'</span>,<span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">header = f.read(<span class="number">54</span>)</span><br><span class="line">file = open(<span class="string">"./modify.bmp"</span>,<span class="string">'wb'</span>)</span><br><span class="line">file.write(header)</span><br><span class="line">writeFile(imageData,file,width)</span><br><span class="line">file.close()</span><br><span class="line"><span class="comment">#展示新文件</span></span><br><span class="line">im = Image.open(<span class="string">'./modify.bmp'</span>)</span><br><span class="line">im.show()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数字内容安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位图文件 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>N-puzzle(1)</title>
      <link href="/2019/03/24/N-puzzle-1/"/>
      <url>/2019/03/24/N-puzzle-1/</url>
      
        <content type="html"><![CDATA[<h4 id="分别生成8，15，24-Puzzle的可解初始状态各1000个（各不相同）"><a href="#分别生成8，15，24-Puzzle的可解初始状态各1000个（各不相同）" class="headerlink" title="分别生成8，15，24-Puzzle的可解初始状态各1000个（各不相同）"></a>分别生成8，15，24-Puzzle的可解初始状态各1000个（各不相同）</h4><p>要求：</p><p>a)使用扑克牌的洗牌策略生成状态</p><p>b)使用Zobrist Hashing构造Hash表，以判断新生成的状态是否已经存在</p><p>c)各取3个初始状态，打印该状态及其后续状态。空格处用#表示，个位数中间对齐，两位数左对齐。</p><a id="more"></a><p><img src="/2019/03/24/N-puzzle-1/QQ截图20190324143721.png" alt="输出示例"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//package n_puzzle;</span></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">N_puzzle</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Scanner scan;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line"><span class="comment">//输入N-puzzle的N</span></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line">scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">N = scan.nextInt();</span><br><span class="line"><span class="comment">//生成（N+1）的棋盘</span></span><br><span class="line">create(N+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] board = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"><span class="keyword">int</span> i,j,temp;</span><br><span class="line"><span class="keyword">int</span> rand;</span><br><span class="line"><span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line">HashSet&lt;Integer&gt; hs = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line"><span class="keyword">int</span>[][] table = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];<span class="comment">//存放每种状态对应的随机数</span></span><br><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">board[i] = i;<span class="comment">//棋盘初值</span></span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">table[i][j] = random.nextInt();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Zobrist Hashing生成hash初始串</span></span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">hash ^= table[j][board[j]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span>;<span class="comment">//计数生成的状态数</span></span><br><span class="line"><span class="comment">//随机洗牌生成不同状态</span></span><br><span class="line"><span class="keyword">while</span>(i &lt; <span class="number">1003</span>)&#123;<span class="comment">//状态数</span></span><br><span class="line"></span><br><span class="line">temp = board[<span class="number">0</span>];</span><br><span class="line">rand = random.nextInt(n);</span><br><span class="line"><span class="comment">//减去要修改的位置的hash</span></span><br><span class="line">hash ^= table[<span class="number">0</span>][board[<span class="number">0</span>]];</span><br><span class="line">hash ^= table[rand][board[rand]];</span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line">board[<span class="number">0</span>] = board[rand];</span><br><span class="line">board[rand] = temp;</span><br><span class="line"><span class="comment">//加上修改过后的hash</span></span><br><span class="line">hash ^= table[<span class="number">0</span>][board[<span class="number">0</span>]];</span><br><span class="line">hash ^= table[rand][board[rand]];</span><br><span class="line"><span class="comment">//判断是否可解</span></span><br><span class="line">        <span class="keyword">if</span>(isSolvable(n,board))&#123;</span><br><span class="line">        <span class="comment">//判断是否重复</span></span><br><span class="line"><span class="keyword">if</span> (hs.add(hash))&#123;</span><br><span class="line">i += <span class="number">1</span>;</span><br><span class="line"><span class="comment">//前1000个输出一维数组</span></span><br><span class="line"><span class="keyword">if</span>(i&lt;=<span class="number">1000</span>)&#123;</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">System.out.print(board[j]+<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最后三个输出棋盘及其后继状态</span></span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"State "</span>+(i-<span class="number">1000</span>)+<span class="string">":"</span>);</span><br><span class="line">printb((<span class="keyword">int</span>)Math.sqrt(n),board);</span><br><span class="line">moveShow(board,(<span class="keyword">int</span>)Math.sqrt(n));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出棋盘函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printb</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> b[])</span></span>&#123;</span><br><span class="line"><span class="comment">//遍历数组输出棋子位置</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n*n; j+= n)&#123;</span><br><span class="line"><span class="comment">//格式化输出棋盘“+---+”</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++)</span><br><span class="line">System.out.print(<span class="string">"+---"</span>);</span><br><span class="line">System.out.println(<span class="string">"+"</span>);</span><br><span class="line"><span class="comment">//格式化输出棋子“| * |”</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = j; i &lt; j+n ;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(b[i] &gt; <span class="number">9</span>)</span><br><span class="line">System.out.print(<span class="string">"|"</span>+b[i]+<span class="string">" "</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(b[i] &gt; <span class="number">0</span>)</span><br><span class="line">System.out.print(<span class="string">"| "</span>+b[i]+<span class="string">" "</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">System.out.print(<span class="string">"| "</span>+<span class="string">"#"</span>+<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"|"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//封底</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++)</span><br><span class="line">System.out.print(<span class="string">"+---"</span>);</span><br><span class="line">System.out.println(<span class="string">"+"</span>);</span><br><span class="line">System.out.println(<span class="string">""</span>);</span><br><span class="line">System.out.println(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是否可解</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSolvable</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> b[])</span></span>&#123;</span><br><span class="line"><span class="comment">//棋盘宽度为奇数且逆序对数为偶数</span></span><br><span class="line"><span class="keyword">if</span>(n%<span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(ReversePair(b) %<span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//棋盘宽度为偶数</span></span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//确定白块所在的行号</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(b[i] == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> row = i/(<span class="keyword">int</span>)Math.sqrt(n) + <span class="number">1</span>;</span><br><span class="line"><span class="comment">//在从上起奇数行且逆序对数为奇数</span></span><br><span class="line"><span class="keyword">if</span>(row % <span class="number">2</span> == <span class="number">1</span> &amp;&amp; ReversePair(b) %<span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">//在从上起偶数行且逆序对数为偶数</span></span><br><span class="line"><span class="keyword">if</span>(row % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; ReversePair(b) %<span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] block,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = block[a];</span><br><span class="line">        block[a] = block[b];</span><br><span class="line">        block[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">moveShow</span><span class="params">(<span class="keyword">int</span>[]blcok,<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lofz = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; blcok.length; i ++)&#123;<span class="comment">//寻找空方块即0的位置</span></span><br><span class="line">            <span class="keyword">if</span>(blcok[i] == <span class="number">0</span>)</span><br><span class="line">                lofz  = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(lofz % N != <span class="number">0</span>)&#123;<span class="comment">//判断空方块是否可以和左边交换</span></span><br><span class="line">          swap(blcok,lofz,lofz-<span class="number">1</span>);</span><br><span class="line">          System.out.println(<span class="string">"move left："</span>);</span><br><span class="line">          printb(N,blcok);</span><br><span class="line">          swap(blcok,lofz,lofz-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(lofz % N != N-<span class="number">1</span>)&#123;<span class="comment">//判断空方块是否可以和右边交换</span></span><br><span class="line">            swap(blcok,lofz,lofz+<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">"move right："</span>);</span><br><span class="line">            printb(N,blcok);</span><br><span class="line">            swap(blcok,lofz,lofz+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(lofz + N &lt;= N*N - <span class="number">1</span>) &#123;</span><br><span class="line">            swap(blcok, lofz, lofz + N);</span><br><span class="line">            System.out.println(<span class="string">"move down："</span>);</span><br><span class="line">            printb(N, blcok);</span><br><span class="line">            swap(blcok, lofz, lofz + N);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(lofz - N &gt;= <span class="number">0</span>)  &#123;</span><br><span class="line">            swap(blcok, lofz, lofz - N);</span><br><span class="line">            System.out.println(<span class="string">"move up："</span>);</span><br><span class="line">            printb(N, blcok);</span><br><span class="line">            swap(blcok, lofz, lofz - N);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//数组中的逆序对</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ReversePair</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array==<span class="keyword">null</span>||array.length&lt;=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//复制数组且删掉白块</span></span><br><span class="line">        <span class="keyword">int</span>[] copy = <span class="keyword">new</span> <span class="keyword">int</span>[array.length-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(array[i] != <span class="number">0</span>)</span><br><span class="line">        copy[k++] = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//临时数组</span></span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            temp[i] = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mergeCount(temp, copy, <span class="number">0</span>, array.length-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mergeCount</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span>[] copy, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start==end)&#123;</span><br><span class="line">            copy[start] = array[start];</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//数组一分为二</span></span><br><span class="line">        <span class="keyword">int</span> mid = (start+end)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//递归左侧</span></span><br><span class="line">        <span class="keyword">int</span> leftCount = mergeCount(copy, array, start, mid);</span><br><span class="line">        <span class="comment">//递归右侧</span></span><br><span class="line">        <span class="keyword">int</span> rightCount = mergeCount(copy, array, mid+<span class="number">1</span>, end);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = mid;<span class="comment">//i初始化为前半段最后一个数字的下标</span></span><br><span class="line">        <span class="keyword">int</span> j = end;<span class="comment">//j初始化为后半段最后一个数字的下标</span></span><br><span class="line">        <span class="keyword">int</span> index = end;<span class="comment">//辅助数组复制的数组的最后一个数字的下标</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//计数--逆序对的数目</span></span><br><span class="line">        <span class="comment">//归并排序且比较</span></span><br><span class="line">        <span class="keyword">while</span>(i&gt;=start&amp;&amp;j&gt;=mid+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i]&gt;array[j])&#123;</span><br><span class="line">                copy[index--] = array[i--];</span><br><span class="line">                count += j-mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                copy[index--] = array[j--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(;i&gt;=start;i--)&#123;<span class="comment">//将剩余的放前面</span></span><br><span class="line">            copy[index--] = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(;j&gt;=mid+<span class="number">1</span>;j--)&#123;<span class="comment">//同上</span></span><br><span class="line">            copy[index--] = array[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> leftCount+rightCount+count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆序对的求解</title>
      <link href="/2019/03/17/%E9%80%86%E5%BA%8F%E5%AF%B9%E7%9A%84%E6%B1%82%E8%A7%A3/"/>
      <url>/2019/03/17/%E9%80%86%E5%BA%8F%E5%AF%B9%E7%9A%84%E6%B1%82%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="逆序对的求解问题"><a href="#逆序对的求解问题" class="headerlink" title="逆序对的求解问题"></a>逆序对的求解问题</h3><p>今天在做课程设计作业时，发现需要求解逆序对的问题，对逆序对求解的算法印象比较模糊了，所以复习了一下。</p><h4 id="逆序对问题"><a href="#逆序对问题" class="headerlink" title="逆序对问题"></a>逆序对问题</h4><p>逆序对：在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。</p><p>输入一个数组,求出这个数组中的逆序对的总数：</p><p>如数组{7,5,6,4}，逆序对总共有5对，{7,5}，{7,6}，{7,4}，{5,4}，{6,4}；</p><a id="more"></a><p><strong>思路1：暴力解法，顺序扫描整个数组，每扫描到一个数字的时候，逐个比较该数字和它后面的数字的大小。如果后面的数字比它小，则这两个数字就组成一个逆序对。假设数组中含有n个数字，由于每个数字都要和O(n)个数字作比较，因此这个算法的时间复杂度是O(n2)。</strong></p><p><strong>思路2：分治思想，采用归并排序的思路来处理，如下图，先分后治：</strong></p><p><img src="/2019/03/17/逆序对的求解/分治.png" alt="分治思想"></p><p>先把数组分解成两个长度为2的子数组，再把这两个子数组分解成两个长度为1的子数组。接下来一边合并相邻的子数组，一边统计逆序对的数目。在第一对长度为1的子数组{7}、{5}中7&gt;5，因此（7,5）组成一个逆序对。同样在第二对长度为1的子数组{6}，{4}中也有逆序对（6,4），由于已经统计了这两对子数组内部的逆序对，因此需要把这两对子数组进行排序，避免在之后的统计过程中重复统计。</p><p><strong>逆序对的总数=左边数组中的逆序对的数量+右边数组中逆序对的数量+左右结合成新的顺序数组时中出现的逆序对的数量；</strong></p><p>总结统计数组逆序对的过程：先把数组分隔成子数组，先统计出子数组内部的逆序对的数目，然后再统计出两个相邻子数组之间的逆序对的数目。在统计逆序对的过程中，还需要对数组进行排序，其实这个排序过程就是归并排序的思路。</p><p>Java实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组中的逆序对</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ReversePair</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array==<span class="keyword">null</span>||array.length&lt;=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] copy = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            copy[i] = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mergeCount(array, copy, <span class="number">0</span>, array.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mergeCount</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span>[] copy, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start==end)&#123;</span><br><span class="line">            copy[start] = array[start];</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (start+end)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> leftCount = mergeCount(copy, array, start, mid);</span><br><span class="line">        <span class="keyword">int</span> rightCount = mergeCount(copy, array, mid+<span class="number">1</span>, end);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = mid;<span class="comment">//i初始化为前半段最后一个数字的下标</span></span><br><span class="line">        <span class="keyword">int</span> j = end;<span class="comment">//j初始化为后半段最后一个数字的下标</span></span><br><span class="line">        <span class="keyword">int</span> index = end;<span class="comment">//辅助数组复制的数组的最后一个数字的下标</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//计数--逆序对的数目</span></span><br><span class="line">        <span class="keyword">while</span>(i&gt;=start&amp;&amp;j&gt;=mid+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i]&gt;array[j])&#123;</span><br><span class="line">                copy[index--] = array[i--];</span><br><span class="line">                count += j-mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                copy[index--] = array[j--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(;i&gt;=start;i--)&#123;<span class="comment">//将剩余的放前面</span></span><br><span class="line">            copy[index--] = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(;j&gt;=mid+<span class="number">1</span>;j--)&#123;<span class="comment">//同上</span></span><br><span class="line">            copy[index--] = array[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> leftCount+rightCount+count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Python 2实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reversePair</span><span class="params">(array)</span>:</span></span><br><span class="line"><span class="keyword">if</span> array:</span><br><span class="line">temp = array[:]</span><br><span class="line">end = len(array)<span class="number">-1</span></span><br><span class="line"><span class="keyword">return</span> mergeCount(array,temp,<span class="number">0</span>,end)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeCount</span><span class="params">(array,temp,start,end)</span>:</span></span><br><span class="line"><span class="keyword">if</span> start <span class="keyword">is</span> end:</span><br><span class="line">temp[start] = array[start]</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">mid = (start + end)/<span class="number">2</span></span><br><span class="line">leftCount = mergeCount(array,temp,start,mid)</span><br><span class="line">rightCount = mergeCount(array,temp,mid+<span class="number">1</span>,end)</span><br><span class="line"></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">i = mid</span><br><span class="line">j = end</span><br><span class="line">k = end</span><br><span class="line">copy = temp[:]</span><br><span class="line"><span class="keyword">while</span> i &gt;= start <span class="keyword">and</span> j &gt;= mid+<span class="number">1</span>:</span><br><span class="line"><span class="keyword">if</span> temp[i] &gt; temp[j]:</span><br><span class="line">copy[k] = temp[i]</span><br><span class="line">count += j - mid</span><br><span class="line">i -= <span class="number">1</span></span><br><span class="line">k -= <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">copy[k] = temp[j]</span><br><span class="line">j -= <span class="number">1</span></span><br><span class="line">k -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> i &gt;= start:</span><br><span class="line">copy[k] = temp[i]</span><br><span class="line">i -= <span class="number">1</span></span><br><span class="line">k -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> j &gt;= mid+<span class="number">1</span>:</span><br><span class="line">copy[k] = temp[j]</span><br><span class="line">j -= <span class="number">1</span></span><br><span class="line">k -= <span class="number">1</span></span><br><span class="line">temp[start:end+<span class="number">1</span>] = copy[start:end+<span class="number">1</span>]</span><br><span class="line"><span class="keyword">return</span> leftCount+rightCount+count</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">array = [<span class="number">7</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">print</span> reversePair(array)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Python </tag>
            
            <tag> 逆序对 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/03/16/hello-world/"/>
      <url>/2019/03/16/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
